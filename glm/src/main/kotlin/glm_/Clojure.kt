package glm_

class Clojure {

    companion object {
        @JvmStatic

        // file: matrix_interpolation.kt
        fun axisAngle(mat: Mat4, axis: Vec3) = glm.axisAngle(mat, axis)
        fun axisAngleMatrix(axis: Vec3, angle: Float) = glm.axisAngleMatrix(axis, angle)
        fun interpolate(m1: Mat4, m2: Mat4, delta: Float) = glm.interpolate(delta)

        // file: mat3x2/Mat3x2d.kt
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)

        // file: mat3x2/Mat3x2.kt
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)

        // file: mat3x2/Mat3x2t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: epsilon.kt
        fun epsilonEqual(a: Mat4, b: Mat4, epsilon: Float) = glm.epsilonEqual(a, b, epsilon)
        fun epsilonEqual(a: Quat, b: Quat, epsilon: Float, res: Vec4bool = Vec4bool()) = glm.epsilonEqual(a: Quat, b: Quat, epsilon: Float, res: Vec4bool = Vec4bool()
        fun epsilonEqual(a: QuatD, b: QuatD, epsilon: Double, res: Vec4bool = Vec4bool()) = glm.epsilonEqual(a: QuatD, b: QuatD, epsilon: Double, res: Vec4bool = Vec4bool()
        fun epsilonNotEqual(a: Quat, b: Quat, epsilon: Float, res: Vec4bool = Vec4bool()) = glm.epsilonNotEqual(a: Quat, b: Quat, epsilon: Float, res: Vec4bool = Vec4bool()
        fun epsilonNotEqual(a: QuatD, b: QuatD, epsilon: Double, res: Vec4bool = Vec4bool()) = glm.epsilonNotEqual(a: QuatD, b: QuatD, epsilon: Double, res: Vec4bool = Vec4bool()

        // file: bitfield.kt
        fun bitfieldInterleave(x: Byte, y: Byte) = glm.bitfieldInterleave(x, y)
        fun bitfieldInterleave(x: Short, y: Short) = glm.bitfieldInterleave(x, y)
        fun bitfieldInterleave(x: Int, y: Int) = glm.bitfieldInterleave(x, y)
        fun bitfieldInterleave(x: Byte, y: Byte, z: Byte) = glm.bitfieldInterleave(x, y, z)
        fun bitfieldInterleave(x: Short, y: Short, z: Short) = glm.bitfieldInterleave(x, y, z)
        fun bitfieldInterleave(x: Int, y: Int, z: Int) = glm.bitfieldInterleave(x, y, z)
        fun bitfieldInterleave(x: Byte, y: Byte, z: Byte, w: Byte) = glm.bitfieldInterleave(x, y, z, w)
        fun bitfieldInterleave(x: Short, y: Short, z: Short, w: Short) = glm.bitfieldInterleave(x, y, z, w)
        fun mask(bits: Vec1i, res: Vec1i = Vec1i()) = glm.mask(bits: Vec1i, res: Vec1i = Vec1i()
        fun mask(bits: Vec2i, res: Vec2i = Vec2i()) = glm.mask(bits: Vec2i, res: Vec2i = Vec2i()
        fun mask(bits: Vec3i, res: Vec3i = Vec3i()) = glm.mask(bits: Vec3i, res: Vec3i = Vec3i()
        fun mask(bits: Vec4i, res: Vec4i = Vec4i()) = glm.mask(bits: Vec4i, res: Vec4i = Vec4i()
        fun bitfieldRotateRight(in_: Vec1i, shift: Int, res: Vec1i = Vec1i()) = glm.bitfieldRotateRight(in_: Vec1i, shift: Int, res: Vec1i = Vec1i()
        fun bitfieldRotateRight(in_: Vec2i, shift: Int, res: Vec2i = Vec2i()) = glm.bitfieldRotateRight(in_: Vec2i, shift: Int, res: Vec2i = Vec2i()
        fun bitfieldRotateRight(in_: Vec3i, shift: Int, res: Vec3i = Vec3i()) = glm.bitfieldRotateRight(in_: Vec3i, shift: Int, res: Vec3i = Vec3i()
        fun bitfieldRotateRight(in_: Vec4i, shift: Int, res: Vec4i = Vec4i()) = glm.bitfieldRotateRight(in_: Vec4i, shift: Int, res: Vec4i = Vec4i()
        fun bitfieldRotateLeft(in_: Vec1i, shift: Int, res: Vec1i = Vec1i()) = glm.bitfieldRotateLeft(in_: Vec1i, shift: Int, res: Vec1i = Vec1i()
        fun bitfieldRotateLeft(in_: Vec2i, shift: Int, res: Vec2i = Vec2i()) = glm.bitfieldRotateLeft(in_: Vec2i, shift: Int, res: Vec2i = Vec2i()
        fun bitfieldRotateLeft(in_: Vec3i, shift: Int, res: Vec3i = Vec3i()) = glm.bitfieldRotateLeft(in_: Vec3i, shift: Int, res: Vec3i = Vec3i()
        fun bitfieldRotateLeft(in_: Vec4i, shift: Int, res: Vec4i = Vec4i()) = glm.bitfieldRotateLeft(in_: Vec4i, shift: Int, res: Vec4i = Vec4i()
        fun bitfieldFillOne(in_: Vec1i, firstBit: Int, bitCount: Int, res: Vec1i = Vec1i()) = glm.bitfieldFillOne(in_: Vec1i, firstBit: Int, bitCount: Int, res: Vec1i = Vec1i()
        fun bitfieldFillOne(in_: Vec2i, firstBit: Int, bitCount: Int, res: Vec2i = Vec2i()) = glm.bitfieldFillOne(in_: Vec2i, firstBit: Int, bitCount: Int, res: Vec2i = Vec2i()
        fun bitfieldFillOne(in_: Vec3i, firstBit: Int, bitCount: Int, res: Vec3i = Vec3i()) = glm.bitfieldFillOne(in_: Vec3i, firstBit: Int, bitCount: Int, res: Vec3i = Vec3i()
        fun bitfieldFillOne(in_: Vec4i, firstBit: Int, bitCount: Int, res: Vec4i = Vec4i()) = glm.bitfieldFillOne(in_: Vec4i, firstBit: Int, bitCount: Int, res: Vec4i = Vec4i()
        fun bitfieldFillZero(in_: Vec1i, firstBit: Int, bitCount: Int, res: Vec1i = Vec1i()) = glm.bitfieldFillZero(in_: Vec1i, firstBit: Int, bitCount: Int, res: Vec1i = Vec1i()
        fun bitfieldFillZero(in_: Vec2i, firstBit: Int, bitCount: Int, res: Vec2i = Vec2i()) = glm.bitfieldFillZero(in_: Vec2i, firstBit: Int, bitCount: Int, res: Vec2i = Vec2i()
        fun bitfieldFillZero(in_: Vec3i, firstBit: Int, bitCount: Int, res: Vec3i = Vec3i()) = glm.bitfieldFillZero(in_: Vec3i, firstBit: Int, bitCount: Int, res: Vec3i = Vec3i()
        fun bitfieldFillZero(in_: Vec4i, firstBit: Int, bitCount: Int, res: Vec4i = Vec4i()) = glm.bitfieldFillZero(in_: Vec4i, firstBit: Int, bitCount: Int, res: Vec4i = Vec4i()

        // file: mat4x3/Mat4x3.kt
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)

        // file: mat4x3/Mat4x3t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: mat4x3/Mat4x3d.kt
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)

        // file: mat2x2/Mat2d.kt
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)
        fun fromPointer(ptr: Ptr, transpose: Boolean = false) = glm.fromPointer(ptr, transpose)

        // file: mat2x2/Mat2.kt
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)
        fun times(b: Mat3x2) = glm.times(b)
        fun times(b: Mat4x2) = glm.times(b)
        fun fromPointer(ptr: Ptr, transpose: Boolean = false) = glm.fromPointer(ptr, transpose)

        // file: mat2x2/operators/mat2x2_operators.kt
        fun plus(res: Mat2, a: Mat2, b: Float) = glm.plus(res, a, b)
        fun minus(res: Mat2, a: Mat2, b: Float) = glm.minus(res, a, b)
        fun minus(res: Mat2, a: Float, b: Mat2) = glm.minus(res, a, b)
        fun times(res: Mat2, a: Mat2, b: Float) = glm.times(res, a, b)
        fun div(res: Mat2, a: Mat2, b: Float) = glm.div(res, a, b)
        fun div(res: Mat2, a: Float, b: Mat2) = glm.div(res, a, b)
        fun plus(res: Mat2, a: Mat2, b00: Float, b01: Float, b10: Float, b11: Float) = glm.plus(res, a)
        fun minus(res: Mat2, a: Mat2, b00: Float, b01: Float, b10: Float, b11: Float) = glm.minus(res, a)
        fun minus(res: Mat2, a00: Float, a01: Float, a10: Float, a11: Float, b: Mat2) = glm.minus(res, b)
        fun times(res: Vec2, a: Mat2, b0: Float, b1: Float) = glm.times(res, a)
        fun times(res: Vec2, a0: Float, a1: Float, b: Mat2) = glm.times(res, b)
        fun times(res: Mat2, a: Mat2, b00: Float, b01: Float, b10: Float, b11: Float) = glm.times(res, a)
        fun div(res: Mat2, a: Mat2, b00: Float, b01: Float, b10: Float, b11: Float) = glm.div(res, a)
        fun div(res: Vec2, a: Mat2, b0: Float, b1: Float) = glm.div(res, a)
        fun div(res: Vec2, a0: Float, a1: Float, b: Mat2) = glm.div(res, b)
        fun Mat2.inc(res: Mat2 = Mat2()) = glm.Mat2.inc(res: Mat2 = Mat2()
        fun Mat2.dec(res: Mat2 = Mat2()) = glm.Mat2.dec(res: Mat2 = Mat2()

        // file: mat2x2/operators/mat2x2d_operators.kt
        fun plus(res: Mat2d, a: Mat2d, b: Double) = glm.plus(res, a, b)
        fun minus(res: Mat2d, a: Mat2d, b: Double) = glm.minus(res, a, b)
        fun minus(res: Mat2d, a: Double, b: Mat2d) = glm.minus(res, a, b)
        fun times(res: Mat2d, a: Mat2d, b: Double) = glm.times(res, a, b)
        fun div(res: Mat2d, a: Mat2d, b: Double) = glm.div(res, a, b)
        fun div(res: Mat2d, a: Double, b: Mat2d) = glm.div(res, a, b)
        fun plus(res: Mat2d, a: Mat2d, b00: Double, b01: Double, b10: Double, b11: Double) = glm.plus(res, a)
        fun minus(res: Mat2d, a: Mat2d, b00: Double, b01: Double, b10: Double, b11: Double) = glm.minus(res, a)
        fun minus(res: Mat2d, a00: Double, a01: Double, a10: Double, a11: Double, b: Mat2d) = glm.minus(res, b)
        fun times(res: Vec2d, a: Mat2d, b0: Double, b1: Double) = glm.times(res, a)
        fun times(res: Vec2d, a0: Double, a1: Double, b: Mat2d) = glm.times(res, b)
        fun times(res: Mat2d, a: Mat2d, b00: Double, b01: Double, b10: Double, b11: Double) = glm.times(res, a)
        fun div(res: Mat2d, a: Mat2d, b00: Double, b01: Double, b10: Double, b11: Double) = glm.div(res, a)
        fun div(res: Vec2d, a: Mat2d, b0: Double, b1: Double) = glm.div(res, a)
        fun div(res: Vec2d, a0: Double, a1: Double, b: Mat2d) = glm.div(res, b)
        fun Mat2d.inc(res: Mat2d = Mat2d()) = glm.Mat2d.inc(res: Mat2d = Mat2d()
        fun Mat2d.dec(res: Mat2d = Mat2d()) = glm.Mat2d.dec(res: Mat2d = Mat2d()

        // file: mat2x2/Mat2x2t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: mat3x3/operators/mat3d_operators.kt
        fun plus(res: Mat3d, a: Mat3d, b: Double) = glm.plus(res, a, b)
        fun minus(res: Mat3d, a: Mat3d, b: Double) = glm.minus(res, a, b)
        fun minus(res: Mat3d, a: Double, b: Mat3d) = glm.minus(res, a, b)
        fun times(res: Mat3d, a: Mat3d, b: Double) = glm.times(res, a, b)
        fun div(res: Mat3d, a: Mat3d, b: Double) = glm.div(res, a, b)
        fun div(res: Mat3d, a: Double, b: Mat3d) = glm.div(res, a, b)
        fun times(res: Vec3d, a: Mat3d, b0: Double, b1: Double, b2: Double) = glm.times(res, a)
        fun times(res: Vec3d, a0: Double, a1: Double, a2: Double, b: Mat3d) = glm.times(res, b)
        fun div(res: Vec3d, a: Mat3d, b0: Double, b1: Double, b2: Double) = glm.div(res, a)
        fun div(res: Vec3d, a0: Double, a1: Double, a2: Double, b: Mat3d) = glm.div(res, b)

        // file: mat3x3/operators/mat3_operators.kt
        fun plus(res: Mat3, a: Mat3, b: Float) = glm.plus(res, a, b)
        fun minus(res: Mat3, a: Mat3, b: Float) = glm.minus(res, a, b)
        fun minus(res: Mat3, a: Float, b: Mat3) = glm.minus(res, a, b)
        fun times(res: Mat3, a: Mat3, b: Float) = glm.times(res, a, b)
        fun div(res: Mat3, a: Mat3, b: Float) = glm.div(res, a, b)
        fun div(res: Mat3, a: Float, b: Mat3) = glm.div(res, a, b)
        fun times(res: Vec3, a: Mat3, b0: Float, b1: Float, b2: Float) = glm.times(res, a)
        fun times(res: Vec3, a0: Float, a1: Float, a2: Float, b: Mat3) = glm.times(res, b)
        fun div(res: Vec3, a: Mat3, b0: Float, b1: Float, b2: Float) = glm.div(res, a)
        fun div(res: Vec3, a0: Float, a1: Float, a2: Float, b: Mat3) = glm.div(res, b)

        // file: mat3x3/Mat3x3t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: mat3x3/Mat3d.kt
        fun to(res: Mat4d) = glm.to(res)
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)
        fun inc(res: Mat3d = Mat3d()) = glm.inc(res: Mat3d = Mat3d()
        fun dec(res: Mat3d = Mat3d()) = glm.dec(res: Mat3d = Mat3d()
        fun fromPointer(ptr: Ptr, transpose: Boolean = false) = glm.fromPointer(ptr, transpose)

        // file: mat3x3/Mat3.kt
        fun to(res: Mat4) = glm.to(res)
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)
        fun inc(res: Mat3 = Mat3()) = glm.inc(res: Mat3 = Mat3()
        fun dec(res: Mat3 = Mat3()) = glm.dec(res: Mat3 = Mat3()
        fun fromPointer(ptr: Ptr, transpose: Boolean = false) = glm.fromPointer(ptr, transpose)

        // file: quat/QuatD.kt
        fun put(w: Double, x: Double, y: Double, z: Double) = glm.put(w, x, y, z)

        // file: quat/gtxQuaternion.kt
        fun cross(res: Vec3, q: Quat, v: Vec3) = glm.cross(res, q, v)
        fun cross(res: Vec3, v: Vec3, q: Quat) = glm.cross(res, v, q)
        fun intermediate(prev: Quat, curr: Quat, next: Quat) = glm.intermediate(prev, curr, next)
        fun exp(q: Quat) = glm.exp(q)
        fun log(q: Quat) = glm.log(q)
        fun pow(x: Quat, y: Float) = glm.pow(x, y)
        fun extractRealComponent(q: Quat) = glm.extractRealComponent(q)
        fun shortMix(x: Quat, y: Quat, a: Float) = glm.shortMix(x, y, a)
        fun rotation(orig: Vec3, dest: Vec3) = glm.rotation(orig, dest)
        fun quatLookAtRH(direction: Vec3, up: Vec3) = glm.quatLookAtRH(direction, up)
        fun quatLookAtLH(direction: Vec3, up: Vec3) = glm.quatLookAtLH(direction, up)

        // file: quat/Quat.kt
        fun put(w: Float, x: Float, y: Float, z: Float) = glm.put(w, x, y, z)

        // file: quat/quatD_operators.kt
        fun plus(res: QuatD, a: QuatD, b: QuatD) = glm.plus(res, a, b)
        fun minus(res: QuatD, a: QuatD, b: QuatD) = glm.minus(res, a, b)
        fun times(res: QuatD, a: QuatD, b: QuatD) = glm.times(res, a, b)
        fun times(res: QuatD, a: QuatD, b: Double) = glm.times(res, a, b)
        fun times(res: Vec3d, a: QuatD, b: Vec3d) = glm.times(res, a, b)
        fun times(res: Vec3d, a: Vec3d, b: QuatD) = glm.times(res, a, b)
        fun times(res: QuatD, a: QuatD, b: Vec4d) = glm.times(res, a, b)
        fun div(res: QuatD, a: QuatD, b: Double) = glm.div(res, a, b)

        // file: quat/quat_operators.kt
        fun plus(res: Quat, a: Quat, b: Quat) = glm.plus(res, a, b)
        fun minus(res: Quat, a: Quat, b: Quat) = glm.minus(res, a, b)
        fun times(res: Quat, a: Quat, b: Quat) = glm.times(res, a, b)
        fun times(res: Quat, a: Quat, b: Float) = glm.times(res, a, b)
        fun times(res: Vec3, a: Quat, b: Vec3) = glm.times(res, a, b)
        fun times(res: Vec3, a: Vec3, b: Quat) = glm.times(res, a, b)
        fun times(res: Quat, a: Quat, b: Vec4) = glm.times(res, a, b)
        fun div(res: Quat, a: Quat, b: Float) = glm.div(res, a, b)

        // file: quat/gtcQuaternion.kt
        fun normalize(q: Quat, res: Quat) = glm.normalize(q, res)
        fun normalize(q: QuatD, res: QuatD) = glm.normalize(q, res)
        fun mix(a: Quat, b: Quat, interp: Float, res: Quat) = glm.mix(a, b, interp, res)
        fun mix(a: QuatD, b: QuatD, interp: Double, res: QuatD) = glm.mix(a, b, interp, res)
        fun lerp(a: Quat, b: Quat, interp: Float, res: Quat) = glm.lerp(a, b, interp, res)
        fun lerp(a: QuatD, b: QuatD, interp: Double, res: QuatD) = glm.lerp(a, b, interp, res)
        fun slerp(a: Quat, b: Quat, interp: Float, res: Quat) = glm.slerp(a, b, interp, res)
        fun slerp(a: QuatD, b: QuatD, interp: Double, res: QuatD) = glm.slerp(a, b, interp, res)
        fun conjugate(a: Quat, res: Quat) = glm.conjugate(a, res)
        fun conjugate(a: QuatD, res: QuatD) = glm.conjugate(a, res)
        fun inverse(a: Quat, res: Quat) = glm.inverse(a, res)
        fun inverse(a: QuatD, res: QuatD) = glm.inverse(a, res)
        fun rotate(q: Quat, angle: Float, vX: Float, vY: Float, vZ: Float, res: Quat) = glm.rotate(q, angle, res)
        fun rotate(q: QuatD, angle: Double, vX: Double, vY: Double, vZ: Double, res: QuatD) = glm.rotate(q, angle, res)
        fun eulerAngles(a: Quat, res: Vec3) = glm.eulerAngles(a, res)
        fun eulerAngles(a: QuatD, res: Vec3d) = glm.eulerAngles(a, res)
        fun pitch(q: Quat) = glm.pitch(q)
        fun mat3_cast(q: Quat, res: Mat3) = glm.mat3_cast(q, res)
        fun mat3d_cast(q: QuatD, m: Mat3) = glm.mat3d_cast(q, m)
        fun mat4_cast(q: Quat, res: Mat4) = glm.mat4_cast(q, res)
        fun mat4d_cast(res: Mat4, q: QuatD) = glm.mat4d_cast(res, q)
        fun axis(q: Quat, res: Vec3) = glm.axis(q, res)
        fun axis(q: QuatD, res: Vec3d) = glm.axis(q, res)
        fun angleAxis(angle: Float, axisX: Float, axisY: Float, axisZ: Float, res: Quat) = glm.angleAxis(angle, res)
        fun angleAxis(angle: Double, axisX: Double, axisY: Double, axisZ: Double, res: QuatD) = glm.angleAxis(angle, res)
        fun lessThan(a: Quat, b: Quat, res: Vec4bool) = glm.lessThan(a, b, res)
        fun lessThanEqual(a: Quat, b: Quat, res: Vec4bool) = glm.lessThanEqual(a, b, res)
        fun greater(a: Quat, b: Quat, res: Vec4bool) = glm.greater(a, b, res)
        fun greaterThan(a: Quat, b: Quat, res: Vec4bool) = glm.greaterThan(a, b, res)
        fun equal(a: Quat, b: Quat, res: Vec4bool) = glm.equal(a, b, res)
        fun notEqual(a: Quat, b: Quat, res: Vec4bool) = glm.notEqual(a, b, res)
        fun isNan(q: Quat, res: Vec4bool) = glm.isNan(q, res)
        fun isInf(q: Quat, res: Vec4bool) = glm.isInf(q, res)

        // file: func_packing.kt
        fun packUnorm2x16(v: Vec2) = glm.packUnorm2x16(v)
        fun unpackUnorm2x16(p: Int, res: Vec2 = Vec2()) = glm.unpackUnorm2x16(p: Int, res: Vec2 = Vec2()
        fun packSnorm2x16(v: Vec2) = glm.packSnorm2x16(v)
        fun unpackSnorm2x16(p: Int, res: Vec2 = Vec2()) = glm.unpackSnorm2x16(p: Int, res: Vec2 = Vec2()
        fun packUnorm4x8(v: Vec4) = glm.packUnorm4x8(v)
        fun unpackUnorm4x8(p: Int, res: Vec4 = Vec4()) = glm.unpackUnorm4x8(p: Int, res: Vec4 = Vec4()
        fun packSnorm4x8(v: Vec4) = glm.packSnorm4x8(v)
        fun unpackSnorm4x8(p: Int, res: Vec4 = Vec4()) = glm.unpackSnorm4x8(p: Int, res: Vec4 = Vec4()

        // file: colorSpace.kt
        fun compute_rgbToSrgb(colorRGB: Vec3, gammaCorrection: Float, res: Vec3) = glm.compute_rgbToSrgb(orrection, res)
        fun compute_rgbToSrgb(colorRGB: Vec4, gammaCorrection: Float, res: Vec4) = glm.compute_rgbToSrgb(orrection, res)
        fun compute_srgbToRgb(colorSRGB: Vec3, gamma: Float, res: Vec3) = glm.compute_srgbToRgb(gamma, res)
        fun compute_srgbToRgb(colorSRGB: Vec4, gamma: Float, res: Vec4) = glm.compute_srgbToRgb(gamma, res)

        // file: detail/Random.kt
        fun get(min: Float, max: Float) = glm.get(min, max)
        fun get(min: Double, max: Double) = glm.get(min, max)
        fun get(min: Vec2, max: Vec2, res: Vec2 = Vec2()) = glm.get(min: Vec2, max: Vec2, res: Vec2 = Vec2()
        fun double(min: Vec2d, max: Vec2d, res: Vec2d = Vec2d()) = glm.double(min: Vec2d, max: Vec2d, res: Vec2d = Vec2d()
        fun float(min: Vec3, max: Vec3, res: Vec3 = Vec3()) = glm.float(min: Vec3, max: Vec3, res: Vec3 = Vec3()
        fun double(min: Vec3d, max: Vec3d, res: Vec3d = Vec3d()) = glm.double(min: Vec3d, max: Vec3d, res: Vec3d = Vec3d()
        fun float(min: Vec4, max: Vec4, res: Vec4 = Vec4()) = glm.float(min: Vec4, max: Vec4, res: Vec4 = Vec4()
        fun double(min: Vec4d, max: Vec4d, res: Vec4d = Vec4d()) = glm.double(min: Vec4d, max: Vec4d, res: Vec4d = Vec4d()

        // file: detail/noise.kt
        fun mod289(a: Number) = glm.mod289(a)
        fun mod289(a: Vec2t<out Number>) = glm.mod289(a)
        fun mod289(a: Vec3t<out Number>) = glm.mod289(a)
        fun mod289(a: Vec4t<out Number>) = glm.mod289(a)
        fun permute(a: Number) = glm.permute(a)
        fun permute(a: Vec2t<out Number>) = glm.permute(a)
        fun permute(a: Vec3t<out Number>) = glm.permute(a)
        fun permute(a: Vec4t<out Number>) = glm.permute(a)
        fun taylorInvSqrt(a: Number) = glm.taylorInvSqrt(a)
        fun taylorInvSqrt(a: Vec2t<out Number>) = glm.taylorInvSqrt(a)
        fun taylorInvSqrt(a: Vec3t<out Number>) = glm.taylorInvSqrt(a)
        fun taylorInvSqrt(a: Vec4t<out Number>) = glm.taylorInvSqrt(a)
        fun fade(a: Vec2t<out Number>) = glm.fade(a)
        fun fade(a: Vec3t<out Number>) = glm.fade(a)
        fun fade(a: Vec4t<out Number>) = glm.fade(a)

        // file: ToBuffer.kt
        fun toBuffer(stack: MemoryStack) = glm.toBuffer(stack)
        fun to(buf: ByteBuffer) = glm.to(buf)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun List<ToBuffer>.to(buf: ByteBuffer) = glm.List<ToBuffer>.to(buf)
        fun List<ToBuffer>.toBuffer(assumeConstSize: Boolean = true) = glm.List<ToBuffer>.toBuffer(ize)
        fun toFloatBuffer(stack: MemoryStack) = glm.toFloatBuffer(stack)
        fun to(buf: FloatBuffer) = glm.to(buf)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)
        fun List<ToFloatBuffer>.to(buf: FloatBuffer) = glm.List<ToFloatBuffer>.to(buf)
        fun List<ToFloatBuffer>.toFloatBuffer(assumeConstSize: Boolean = true) = glm.List<ToFloatBuffer>.toFloatBuffer(ize)
        fun toDoubleBuffer(stack: MemoryStack) = glm.toDoubleBuffer(stack)
        fun to(buf: DoubleBuffer) = glm.to(buf)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)
        fun List<ToDoubleBuffer>.to(buf: DoubleBuffer) = glm.List<ToDoubleBuffer>.to(buf)
        fun List<ToDoubleBuffer>.toDoubleBuffer(assumeConstSize: Boolean = true) = glm.List<ToDoubleBuffer>.toDoubleBuffer(ize)

        // file: func/func_exponential.kt
        fun pow(base: Vec1, exponent: Float, res: Vec1 = Vec1()) = glm.pow(base: Vec1, exponent: Float, res: Vec1 = Vec1()
        fun pow(base: Vec1, exponent: Vec1, res: Vec1 = Vec1()) = glm.pow(base: Vec1, exponent: Vec1, res: Vec1 = Vec1()
        fun pow(base: Vec1d, exponent: Double, res: Vec1d = Vec1d()) = glm.pow(base: Vec1d, exponent: Double, res: Vec1d = Vec1d()
        fun pow(base: Vec1d, exponent: Vec1d, res: Vec1d = Vec1d()) = glm.pow(base: Vec1d, exponent: Vec1d, res: Vec1d = Vec1d()
        fun pow(base: Vec2, exponent: Float, res: Vec2 = Vec2()) = glm.pow(base: Vec2, exponent: Float, res: Vec2 = Vec2()
        fun pow(base: Vec2, exponent: Vec2, res: Vec2 = Vec2()) = glm.pow(base: Vec2, exponent: Vec2, res: Vec2 = Vec2()
        fun pow(base: Vec2d, exponent: Double, res: Vec2d = Vec2d()) = glm.pow(base: Vec2d, exponent: Double, res: Vec2d = Vec2d()
        fun pow(base: Vec2d, exponent: Vec2d, res: Vec2d = Vec2d()) = glm.pow(base: Vec2d, exponent: Vec2d, res: Vec2d = Vec2d()
        fun pow(base: Vec3, exponent: Float, res: Vec3 = Vec3()) = glm.pow(base: Vec3, exponent: Float, res: Vec3 = Vec3()
        fun pow(base: Vec3, exponent: Vec3, res: Vec3 = Vec3()) = glm.pow(base: Vec3, exponent: Vec3, res: Vec3 = Vec3()
        fun pow(base: Vec3d, exponent: Double, res: Vec3d = Vec3d()) = glm.pow(base: Vec3d, exponent: Double, res: Vec3d = Vec3d()
        fun pow(base: Vec3d, exponent: Vec3d, res: Vec3d = Vec3d()) = glm.pow(base: Vec3d, exponent: Vec3d, res: Vec3d = Vec3d()
        fun pow(base: Vec4, exponent: Float, res: Vec4 = Vec4()) = glm.pow(base: Vec4, exponent: Float, res: Vec4 = Vec4()
        fun pow(base: Vec4, exponent: Vec4, res: Vec4 = Vec4()) = glm.pow(base: Vec4, exponent: Vec4, res: Vec4 = Vec4()
        fun pow(base: Vec4d, exponent: Double, res: Vec4d = Vec4d()) = glm.pow(base: Vec4d, exponent: Double, res: Vec4d = Vec4d()
        fun pow(base: Vec4d, exponent: Vec4d, res: Vec4d = Vec4d()) = glm.pow(base: Vec4d, exponent: Vec4d, res: Vec4d = Vec4d()
        fun exp(a: Vec1, res: Vec1 = Vec1()) = glm.exp(a: Vec1, res: Vec1 = Vec1()
        fun exp(a: Vec1d, res: Vec1d = Vec1d()) = glm.exp(a: Vec1d, res: Vec1d = Vec1d()
        fun exp(a: Vec2, res: Vec2 = Vec2()) = glm.exp(a: Vec2, res: Vec2 = Vec2()
        fun exp(a: Vec2d, res: Vec2d = Vec2d()) = glm.exp(a: Vec2d, res: Vec2d = Vec2d()
        fun exp(a: Vec3, res: Vec3 = Vec3()) = glm.exp(a: Vec3, res: Vec3 = Vec3()
        fun exp(a: Vec3d, res: Vec3d = Vec3d()) = glm.exp(a: Vec3d, res: Vec3d = Vec3d()
        fun exp(a: Vec4, res: Vec4 = Vec4()) = glm.exp(a: Vec4, res: Vec4 = Vec4()
        fun exp(a: Vec4d, res: Vec4d = Vec4d()) = glm.exp(a: Vec4d, res: Vec4d = Vec4d()
        fun log(a: Vec1, res: Vec1 = Vec1()) = glm.log(a: Vec1, res: Vec1 = Vec1()
        fun log(a: Vec1d, res: Vec1d = Vec1d()) = glm.log(a: Vec1d, res: Vec1d = Vec1d()
        fun log(a: Vec2, res: Vec2 = Vec2()) = glm.log(a: Vec2, res: Vec2 = Vec2()
        fun log(a: Vec2d, res: Vec2d = Vec2d()) = glm.log(a: Vec2d, res: Vec2d = Vec2d()
        fun log(a: Vec3, res: Vec3 = Vec3()) = glm.log(a: Vec3, res: Vec3 = Vec3()
        fun log(a: Vec3d, res: Vec3d = Vec3d()) = glm.log(a: Vec3d, res: Vec3d = Vec3d()
        fun log(a: Vec4, res: Vec4 = Vec4()) = glm.log(a: Vec4, res: Vec4 = Vec4()
        fun log(a: Vec4d, res: Vec4d = Vec4d()) = glm.log(a: Vec4d, res: Vec4d = Vec4d()
        fun exp2(a: Vec1, res: Vec1 = Vec1()) = glm.exp2(a: Vec1, res: Vec1 = Vec1()
        fun exp2(a: Vec1d, res: Vec1d = Vec1d()) = glm.exp2(a: Vec1d, res: Vec1d = Vec1d()
        fun exp2(a: Vec2, res: Vec2 = Vec2()) = glm.exp2(a: Vec2, res: Vec2 = Vec2()
        fun exp2(a: Vec2d, res: Vec2d = Vec2d()) = glm.exp2(a: Vec2d, res: Vec2d = Vec2d()
        fun exp2(a: Vec3, res: Vec3 = Vec3()) = glm.exp2(a: Vec3, res: Vec3 = Vec3()
        fun exp2(a: Vec3d, res: Vec3d = Vec3d()) = glm.exp2(a: Vec3d, res: Vec3d = Vec3d()
        fun exp2(a: Vec4, res: Vec4 = Vec4()) = glm.exp2(a: Vec4, res: Vec4 = Vec4()
        fun exp2(a: Vec4d, res: Vec4d = Vec4d()) = glm.exp2(a: Vec4d, res: Vec4d = Vec4d()
        fun log2(a: Vec1, res: Vec1 = Vec1()) = glm.log2(a: Vec1, res: Vec1 = Vec1()
        fun log2(a: Vec1d, res: Vec1d = Vec1d()) = glm.log2(a: Vec1d, res: Vec1d = Vec1d()
        fun log2(a: Vec2, res: Vec2 = Vec2()) = glm.log2(a: Vec2, res: Vec2 = Vec2()
        fun log2(a: Vec2d, res: Vec2d = Vec2d()) = glm.log2(a: Vec2d, res: Vec2d = Vec2d()
        fun log2(a: Vec3, res: Vec3 = Vec3()) = glm.log2(a: Vec3, res: Vec3 = Vec3()
        fun log2(a: Vec3d, res: Vec3d = Vec3d()) = glm.log2(a: Vec3d, res: Vec3d = Vec3d()
        fun log2(a: Vec4, res: Vec4 = Vec4()) = glm.log2(a: Vec4, res: Vec4 = Vec4()
        fun log2(a: Vec4d, res: Vec4d = Vec4d()) = glm.log2(a: Vec4d, res: Vec4d = Vec4d()
        fun sqrt(a: Vec1, res: Vec1 = Vec1()) = glm.sqrt(a: Vec1, res: Vec1 = Vec1()
        fun sqrt(a: Vec1d, res: Vec1d = Vec1d()) = glm.sqrt(a: Vec1d, res: Vec1d = Vec1d()
        fun sqrt(a: Vec2, res: Vec2 = Vec2()) = glm.sqrt(a: Vec2, res: Vec2 = Vec2()
        fun sqrt(a: Vec2d, res: Vec2d = Vec2d()) = glm.sqrt(a: Vec2d, res: Vec2d = Vec2d()
        fun sqrt(a: Vec3, res: Vec3 = Vec3()) = glm.sqrt(a: Vec3, res: Vec3 = Vec3()
        fun sqrt(a: Vec3d, res: Vec3d = Vec3d()) = glm.sqrt(a: Vec3d, res: Vec3d = Vec3d()
        fun sqrt(a: Vec4, res: Vec4 = Vec4()) = glm.sqrt(a: Vec4, res: Vec4 = Vec4()
        fun sqrt(a: Vec4d, res: Vec4d = Vec4d()) = glm.sqrt(a: Vec4d, res: Vec4d = Vec4d()
        fun inverseSqrt(a: Vec1, res: Vec1 = Vec1()) = glm.inverseSqrt(a: Vec1, res: Vec1 = Vec1()
        fun inverseSqrt(a: Vec1d, res: Vec1d = Vec1d()) = glm.inverseSqrt(a: Vec1d, res: Vec1d = Vec1d()
        fun inverseSqrt(a: Vec2, res: Vec2 = Vec2()) = glm.inverseSqrt(a: Vec2, res: Vec2 = Vec2()
        fun inverseSqrt(a: Vec2d, res: Vec2d = Vec2d()) = glm.inverseSqrt(a: Vec2d, res: Vec2d = Vec2d()
        fun inverseSqrt(a: Vec3, res: Vec3 = Vec3()) = glm.inverseSqrt(a: Vec3, res: Vec3 = Vec3()
        fun inverseSqrt(a: Vec3d, res: Vec3d = Vec3d()) = glm.inverseSqrt(a: Vec3d, res: Vec3d = Vec3d()
        fun inverseSqrt(a: Vec4, res: Vec4 = Vec4()) = glm.inverseSqrt(a: Vec4, res: Vec4 = Vec4()
        fun inverseSqrt(a: Vec4d, res: Vec4d = Vec4d()) = glm.inverseSqrt(a: Vec4d, res: Vec4d = Vec4d()

        // file: func/func_trigonometric.kt
        fun degrees(rad: Vec2, res: Vec2) = glm.degrees(rad, res)
        fun degrees(rad: Vec2d, res: Vec2d) = glm.degrees(rad, res)
        fun degrees(rad: Vec3, res: Vec3) = glm.degrees(rad, res)
        fun degrees(rad: Vec3d, res: Vec3d) = glm.degrees(rad, res)
        fun degrees(rad: Vec4, res: Vec4) = glm.degrees(rad, res)
        fun degrees(rad: Vec4d, res: Vec4d) = glm.degrees(rad, res)
        fun radians(deg: Vec2, res: Vec2) = glm.radians(deg, res)
        fun radians(deg: Vec2d, res: Vec2d) = glm.radians(deg, res)
        fun radians(deg: Vec3, res: Vec3) = glm.radians(deg, res)
        fun radians(deg: Vec3d, res: Vec3d) = glm.radians(deg, res)
        fun radians(deg: Vec4, res: Vec4) = glm.radians(deg, res)
        fun radians(deg: Vec4d, res: Vec4d) = glm.radians(deg, res)

        // file: func/func_geometric.kt
        fun cross(a: Vec3, b: Vec3, res: Vec3 = Vec3()) = glm.cross(a: Vec3, b: Vec3, res: Vec3 = Vec3()
        fun cross(a: Vec3d, b: Vec3d, res: Vec3d = Vec3d()) = glm.cross(a: Vec3d, b: Vec3d, res: Vec3d = Vec3d()
        fun cross(a: Quat, b: Quat, res: Quat = Quat()) = glm.cross(a: Quat, b: Quat, res: Quat = Quat()
        fun normalize(a: Vec2, res: Vec2 = Vec2()) = glm.normalize(a: Vec2, res: Vec2 = Vec2()
        fun normalize(a: Vec2d, res: Vec2d = Vec2d()) = glm.normalize(a: Vec2d, res: Vec2d = Vec2d()
        fun normalize(a: Vec3, res: Vec3 = Vec3()) = glm.normalize(a: Vec3, res: Vec3 = Vec3()
        fun normalize(a: Vec3d, res: Vec3d = Vec3d()) = glm.normalize(a: Vec3d, res: Vec3d = Vec3d()
        fun normalize(a: Vec4, res: Vec4 = Vec4()) = glm.normalize(a: Vec4, res: Vec4 = Vec4()
        fun normalize(a: Vec4d, res: Vec4d = Vec4d()) = glm.normalize(a: Vec4d, res: Vec4d = Vec4d()
        fun faceForward(n: Vec2, i: Vec2, nRef: Vec2, res: Vec2 = Vec2()) = glm.faceForward(n: Vec2, i: Vec2, nRef: Vec2, res: Vec2 = Vec2()
        fun faceForward(n: Vec2d, i: Vec2d, nRef: Vec2d, res: Vec2d = Vec2d()) = glm.faceForward(n: Vec2d, i: Vec2d, nRef: Vec2d, res: Vec2d = Vec2d()
        fun faceForward(n: Vec3, i: Vec3, nRef: Vec3, res: Vec3 = Vec3()) = glm.faceForward(n: Vec3, i: Vec3, nRef: Vec3, res: Vec3 = Vec3()
        fun faceForward(n: Vec3d, i: Vec3d, nRef: Vec3d, res: Vec3d = Vec3d()) = glm.faceForward(n: Vec3d, i: Vec3d, nRef: Vec3d, res: Vec3d = Vec3d()
        fun faceForward(n: Vec4, i: Vec4, nRef: Vec4, res: Vec4 = Vec4()) = glm.faceForward(n: Vec4, i: Vec4, nRef: Vec4, res: Vec4 = Vec4()
        fun faceForward(n: Vec4d, i: Vec4d, nRef: Vec4d, res: Vec4d = Vec4d()) = glm.faceForward(n: Vec4d, i: Vec4d, nRef: Vec4d, res: Vec4d = Vec4d()
        fun reflect(i: Vec2, n: Vec2, res: Vec2 = Vec2()) = glm.reflect(i: Vec2, n: Vec2, res: Vec2 = Vec2()
        fun reflect(i: Vec2d, n: Vec2d, res: Vec2d = Vec2d()) = glm.reflect(i: Vec2d, n: Vec2d, res: Vec2d = Vec2d()
        fun reflect(i: Vec3, n: Vec3, res: Vec3 = Vec3()) = glm.reflect(i: Vec3, n: Vec3, res: Vec3 = Vec3()
        fun reflect(i: Vec3d, n: Vec3d, res: Vec3d = Vec3d()) = glm.reflect(i: Vec3d, n: Vec3d, res: Vec3d = Vec3d()
        fun reflect(i: Vec4, n: Vec4, res: Vec4 = Vec4()) = glm.reflect(i: Vec4, n: Vec4, res: Vec4 = Vec4()
        fun reflect(i: Vec4d, n: Vec4d, res: Vec4d = Vec4d()) = glm.reflect(i: Vec4d, n: Vec4d, res: Vec4d = Vec4d()
        fun refract(i: Float, n: Float, eta: Float) = glm.refract(i, n, eta)
        fun refract(i: Double, n: Double, eta: Double) = glm.refract(i, n, eta)
        fun refract(i: Vec2, n: Vec2, eta: Number, res: Vec2 = Vec2()) = glm.refract(i: Vec2, n: Vec2, eta: Number, res: Vec2 = Vec2()
        fun refract(i: Vec2d, n: Vec2d, eta: Number, res: Vec2d = Vec2d()) = glm.refract(i: Vec2d, n: Vec2d, eta: Number, res: Vec2d = Vec2d()
        fun refract(i: Vec3, n: Vec3, eta: Number, res: Vec3 = Vec3()) = glm.refract(i: Vec3, n: Vec3, eta: Number, res: Vec3 = Vec3()
        fun refract(i: Vec3d, n: Vec3d, eta: Number, res: Vec3d = Vec3d()) = glm.refract(i: Vec3d, n: Vec3d, eta: Number, res: Vec3d = Vec3d()
        fun refract(i: Vec4, n: Vec4, eta: Number, res: Vec4 = Vec4()) = glm.refract(i: Vec4, n: Vec4, eta: Number, res: Vec4 = Vec4()
        fun refract(i: Vec4d, n: Vec4d, eta: Number, res: Vec4d = Vec4d()) = glm.refract(i: Vec4d, n: Vec4d, eta: Number, res: Vec4d = Vec4d()

        // file: func/common/func_vector3_common.kt
        fun abs(a: Vec3, res: Vec3) = glm.abs(a, res)
        fun abs(a: Vec3b, res: Vec3b) = glm.abs(a, res)
        fun abs(a: Vec3d, res: Vec3d) = glm.abs(a, res)
        fun abs(a: Vec3i, res: Vec3i) = glm.abs(a, res)
        fun abs(a: Vec3l, res: Vec3l) = glm.abs(a, res)
        fun abs(a: Vec3s, res: Vec3s) = glm.abs(a, res)
        fun sign(a: Vec3, res: Vec3) = glm.sign(a, res)
        fun sign(a: Vec3b, res: Vec3b) = glm.sign(a, res)
        fun sign(a: Vec3d, res: Vec3d) = glm.sign(a, res)
        fun sign(a: Vec3i, res: Vec3i) = glm.sign(a, res)
        fun sign(a: Vec3l, res: Vec3l) = glm.sign(a, res)
        fun sign(a: Vec3s, res: Vec3s) = glm.sign(a, res)
        fun floor(a: Vec3, res: Vec3) = glm.floor(a, res)
        fun floor(a: Vec3d, res: Vec3d) = glm.floor(a, res)
        fun trunc(a: Vec3, res: Vec3) = glm.trunc(a, res)
        fun trunc(a: Vec3d, res: Vec3d) = glm.trunc(a, res)
        fun round(a: Vec3, res: Vec3) = glm.round(a, res)
        fun round(a: Vec3d, res: Vec3d) = glm.round(a, res)
        fun ceil(a: Vec3, res: Vec3) = glm.ceil(a, res)
        fun ceil(a: Vec3d, res: Vec3d) = glm.ceil(a, res)
        fun fract(a: Vec3, res: Vec3) = glm.fract(a, res)
        fun fract(a: Vec3d, res: Vec3d) = glm.fract(a, res)
        fun mod(a: Vec3, b: Float, res: Vec3) = glm.mod(a, b, res)
        fun mod(a: Vec3d, b: Double, res: Vec3d) = glm.mod(a, b, res)
        fun mod(a: Vec3, b: Vec3, res: Vec3) = glm.mod(a, b, res)
        fun mod(a: Vec3d, b: Vec3d, res: Vec3d) = glm.mod(a, b, res)
        fun min(a: Vec3, b: Float, res: Vec3) = glm.min(a, b, res)
        fun min(a: Vec3d, b: Double, res: Vec3d) = glm.min(a, b, res)
        fun min(a: Vec3, b: Vec3, res: Vec3) = glm.min(a, b, res)
        fun min(a: Vec3d, b: Vec3d, res: Vec3d) = glm.min(a, b, res)
        fun min(a: Vec3i, b: Int, res: Vec3i) = glm.min(a, b, res)
        fun min(a: Vec3i, b: Vec3i, res: Vec3i) = glm.min(a, b, res)
        fun max(a: Vec3, b: Float, res: Vec3) = glm.max(a, b, res)
        fun max(a: Vec3d, b: Double, res: Vec3d) = glm.max(a, b, res)
        fun max(a: Vec3, b: Vec3, res: Vec3) = glm.max(a, b, res)
        fun max(a: Vec3d, b: Vec3d, res: Vec3d) = glm.max(a, b, res)
        fun max(a: Vec3i, b: Int, res: Vec3i) = glm.max(a, b, res)
        fun max(a: Vec3i, b: Vec3i, res: Vec3i) = glm.max(a, b, res)
        fun clamp(a: Vec3, min: Float, max: Float, res: Vec3) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec3d, min: Double, max: Double, res: Vec3d) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec3, min: Vec3, max: Vec3, res: Vec3) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec3d, min: Vec3d, max: Vec3d, res: Vec3d) = glm.clamp(a, min, max, res)
        fun mix(a: Vec3, b: Vec3, interp: Float, res: Vec3) = glm.mix(a, b, interp, res)
        fun mix(a: Vec3d, b: Vec3d, interp: Double, res: Vec3d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec3, b: Vec3, interp: Boolean, res: Vec3) = glm.mix(a, b, interp, res)
        fun mix(a: Vec3d, b: Vec3d, interp: Boolean, res: Vec3d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec3, b: Vec3, interp: Vec3, res: Vec3) = glm.mix(a, b, interp, res)
        fun mix(a: Vec3d, b: Vec3d, interp: Vec3d, res: Vec3d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec3, b: Vec3, interp: Vec3bool, res: Vec3) = glm.mix(a, b, interp, res)
        fun mix(a: Vec3d, b: Vec3d, interp: Vec3bool, res: Vec3d) = glm.mix(a, b, interp, res)
        fun step(edge: Float, a: Vec3, res: Vec3) = glm.step(edge, a, res)
        fun step(edge: Double, a: Vec3d, res: Vec3d) = glm.step(edge, a, res)
        fun step(edge: Vec3, a: Vec3, res: Vec3) = glm.step(edge, a, res)
        fun step(edge: Vec3d, a: Vec3d, res: Vec3d) = glm.step(edge, a, res)
        fun smoothStep(edge0: Float, edge1: Float, a: Vec3, res: Vec3) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Double, edge1: Double, a: Vec3d, res: Vec3d) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Vec3, edge1: Vec3, a: Vec3, res: Vec3) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Vec3d, edge1: Vec3d, a: Vec3d, res: Vec3d) = glm.smoothStep(a, res)
        fun isNan(a: Vec3, res: Vec3bool) = glm.isNan(a, res)
        fun isNan(a: Vec3d, res: Vec3bool) = glm.isNan(a, res)
        fun isInf(a: Vec3, res: Vec3bool) = glm.isInf(a, res)
        fun isInf(a: Vec3d, res: Vec3bool) = glm.isInf(a, res)
        fun floatBitsToInt(a: Vec3, res: Vec3i) = glm.floatBitsToInt(a, res)
        fun floatBitsToUint(a: Vec3, res: Vec3ui) = glm.floatBitsToUint(a, res)
        fun intBitsToFloat(a: Vec3i, res: Vec3) = glm.intBitsToFloat(a, res)
        fun uintBitsToFloat(a: Vec3ui, res: Vec3) = glm.uintBitsToFloat(a, res)
        fun fma(a: Vec3, b: Vec3, c: Vec3, res: Vec3) = glm.fma(a, b, c, res)
        fun fma(a: Vec3d, b: Vec3d, c: Vec3d, res: Vec3d) = glm.fma(a, b, c, res)
        fun frexp(a: Vec3, exp: Vec3i, res: Vec3) = glm.frexp(a, exp, res)
        fun frexp(a: Vec3d, exp: Vec3i, res: Vec3d) = glm.frexp(a, exp, res)
        fun ldexp(a: Vec3, exp: Vec3i, res: Vec3) = glm.ldexp(a, exp, res)
        fun ldexp(a: Vec3d, exp: Vec3i, res: Vec3d) = glm.ldexp(a, exp, res)

        // file: func/common/func_vector1_common.kt
        fun abs(a: Vec1, res: Vec1) = glm.abs(a, res)
        fun abs(a: Vec1b, res: Vec1b) = glm.abs(a, res)
        fun abs(a: Vec1d, res: Vec1d) = glm.abs(a, res)
        fun abs(a: Vec1i, res: Vec1i) = glm.abs(a, res)
        fun abs(a: Vec1l, res: Vec1l) = glm.abs(a, res)
        fun abs(a: Vec1s, res: Vec1s) = glm.abs(a, res)
        fun sign(a: Vec1, res: Vec1) = glm.sign(a, res)
        fun sign(a: Vec1b, res: Vec1b) = glm.sign(a, res)
        fun sign(a: Vec1d, res: Vec1d) = glm.sign(a, res)
        fun sign(a: Vec1i, res: Vec1i) = glm.sign(a, res)
        fun sign(a: Vec1l, res: Vec1l) = glm.sign(a, res)
        fun sign(a: Vec1s, res: Vec1s) = glm.sign(a, res)
        fun floor(a: Vec1, res: Vec1) = glm.floor(a, res)
        fun floor(a: Vec1d, res: Vec1d) = glm.floor(a, res)
        fun trunc(a: Vec1, res: Vec1) = glm.trunc(a, res)
        fun trunc(a: Vec1d, res: Vec1d) = glm.trunc(a, res)
        fun round(a: Vec1, res: Vec1) = glm.round(a, res)
        fun round(a: Vec1d, res: Vec1d) = glm.round(a, res)
        fun ceil(a: Vec1, res: Vec1) = glm.ceil(a, res)
        fun ceil(a: Vec1d, res: Vec1d) = glm.ceil(a, res)
        fun fract(a: Vec1, res: Vec1) = glm.fract(a, res)
        fun fract(a: Vec1d, res: Vec1d) = glm.fract(a, res)
        fun mod(a: Vec1, b: Float, res: Vec1) = glm.mod(a, b, res)
        fun mod(a: Vec1d, b: Double, res: Vec1d) = glm.mod(a, b, res)
        fun mod(a: Vec1, b: Vec1, res: Vec1) = glm.mod(a, b, res)
        fun mod(a: Vec1d, b: Vec1d, res: Vec1d) = glm.mod(a, b, res)
        fun min(a: Vec1, b: Float, res: Vec1) = glm.min(a, b, res)
        fun min(a: Vec1d, b: Double, res: Vec1d) = glm.min(a, b, res)
        fun min(a: Vec1, b: Vec1, res: Vec1) = glm.min(a, b, res)
        fun min(a: Vec1d, b: Vec1d, res: Vec1d) = glm.min(a, b, res)
        fun min(a: Vec1i, b: Int, res: Vec1i) = glm.min(a, b, res)
        fun min(a: Vec1i, b: Vec1i, res: Vec1i) = glm.min(a, b, res)
        fun min(a: Vec1b, b: Byte, res: Vec1b) = glm.min(a, b, res)
        fun min(a: Vec1b, b: Vec1b, res: Vec1b) = glm.min(a, b, res)
        fun max(a: Vec1, b: Float, res: Vec1) = glm.max(a, b, res)
        fun max(a: Vec1d, b: Double, res: Vec1d) = glm.max(a, b, res)
        fun max(a: Vec1, b: Vec1, res: Vec1) = glm.max(a, b, res)
        fun max(a: Vec1d, b: Vec1d, res: Vec1d) = glm.max(a, b, res)
        fun max(a: Vec1i, b: Int, res: Vec1i) = glm.max(a, b, res)
        fun max(a: Vec1i, b: Vec1i, res: Vec1i) = glm.max(a, b, res)
        fun max(a: Vec1b, b: Byte, res: Vec1b) = glm.max(a, b, res)
        fun max(a: Vec1b, b: Vec1b, res: Vec1b) = glm.max(a, b, res)
        fun clamp(a: Vec1, min: Float, max: Float, res: Vec1) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec1d, min: Double, max: Double, res: Vec1d) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec1, min: Vec1, max: Vec1, res: Vec1) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec1d, min: Vec1d, max: Vec1d, res: Vec1d) = glm.clamp(a, min, max, res)
        fun mix(a: Vec1, b: Vec1, interp: Float, res: Vec1) = glm.mix(a, b, interp, res)
        fun mix(a: Vec1d, b: Vec1d, interp: Double, res: Vec1d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec1, b: Vec1, interp: Boolean, res: Vec1) = glm.mix(a, b, interp, res)
        fun mix(a: Vec1d, b: Vec1d, interp: Boolean, res: Vec1d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec1, b: Vec1, interp: Vec1, res: Vec1) = glm.mix(a, b, interp, res)
        fun mix(a: Vec1d, b: Vec1d, interp: Vec1d, res: Vec1d = Vec1d()) = glm.mix(a: Vec1d, b: Vec1d, interp: Vec1d, res: Vec1d = Vec1d()
        fun mix(a: Vec1, b: Vec1, interp: Vec1bool, res: Vec1) = glm.mix(a, b, interp, res)
        fun mix(a: Vec1d, b: Vec1d, interp: Vec1bool, res: Vec1d) = glm.mix(a, b, interp, res)
        fun step(edge: Float, a: Vec1, res: Vec1) = glm.step(edge, a, res)
        fun step(edge: Double, a: Vec1d, res: Vec1d) = glm.step(edge, a, res)
        fun step(edge: Vec1, a: Vec1, res: Vec1) = glm.step(edge, a, res)
        fun step(edge: Vec1d, a: Vec1d, res: Vec1d) = glm.step(edge, a, res)
        fun smoothStep(edge0: Float, edge1: Float, a: Vec1, res: Vec1) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Double, edge1: Double, a: Vec1d, res: Vec1d) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Vec1, edge1: Vec1, a: Vec1, res: Vec1) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Vec1d, edge1: Vec1d, a: Vec1d, res: Vec1d) = glm.smoothStep(a, res)
        fun isNan(a: Vec1, res: Vec1bool) = glm.isNan(a, res)
        fun isNan(a: Vec1d, res: Vec1bool) = glm.isNan(a, res)
        fun isInf(a: Vec1, res: Vec1bool) = glm.isInf(a, res)
        fun isInf(a: Vec1d, res: Vec1bool) = glm.isInf(a, res)
        fun floatBitsToInt(a: Vec1, res: Vec1i) = glm.floatBitsToInt(a, res)
        fun floatBitsToUint(a: Vec1, res: Vec1ui) = glm.floatBitsToUint(a, res)
        fun intBitsToFloat(a: Vec1i, res: Vec1) = glm.intBitsToFloat(a, res)
        fun uintBitsToFloat(a: Vec1ui, res: Vec1) = glm.uintBitsToFloat(a, res)
        fun fma(a: Vec1, b: Vec1, c: Vec1, res: Vec1) = glm.fma(a, b, c, res)
        fun fma(a: Vec1d, b: Vec1d, c: Vec1d, res: Vec1d) = glm.fma(a, b, c, res)
        fun frexp(a: Vec1, exp: Vec1i, res: Vec1) = glm.frexp(a, exp, res)
        fun frexp(a: Vec1d, exp: Vec1i, res: Vec1d) = glm.frexp(a, exp, res)
        fun ldexp(a: Vec1, exp: Vec1i, res: Vec1) = glm.ldexp(a, exp, res)
        fun ldexp(a: Vec1d, exp: Vec1i, res: Vec1d) = glm.ldexp(a, exp, res)

        // file: func/common/func_vector4_common.kt
        fun abs(a: Vec4, res: Vec4) = glm.abs(a, res)
        fun abs(a: Vec4b, res: Vec4b) = glm.abs(a, res)
        fun abs(a: Vec4d, res: Vec4d) = glm.abs(a, res)
        fun abs(a: Vec4i, res: Vec4i) = glm.abs(a, res)
        fun abs(a: Vec4l, res: Vec4l) = glm.abs(a, res)
        fun abs(a: Vec4s, res: Vec4s) = glm.abs(a, res)
        fun sign(a: Vec4, res: Vec4) = glm.sign(a, res)
        fun sign(a: Vec4b, res: Vec4b) = glm.sign(a, res)
        fun sign(a: Vec4d, res: Vec4d) = glm.sign(a, res)
        fun sign(a: Vec4i, res: Vec4i) = glm.sign(a, res)
        fun sign(a: Vec4l, res: Vec4l) = glm.sign(a, res)
        fun sign(a: Vec4s, res: Vec4s) = glm.sign(a, res)
        fun floor(a: Vec4, res: Vec4) = glm.floor(a, res)
        fun floor(a: Vec4d, res: Vec4d) = glm.floor(a, res)
        fun trunc(a: Vec4, res: Vec4) = glm.trunc(a, res)
        fun trunc(a: Vec4d, res: Vec4d) = glm.trunc(a, res)
        fun round(a: Vec4, res: Vec4) = glm.round(a, res)
        fun round(a: Vec4d, res: Vec4d) = glm.round(a, res)
        fun ceil(a: Vec4, res: Vec4) = glm.ceil(a, res)
        fun ceil(a: Vec4d, res: Vec4d) = glm.ceil(a, res)
        fun fract(a: Vec4, res: Vec4) = glm.fract(a, res)
        fun fract(a: Vec4d, res: Vec4d) = glm.fract(a, res)
        fun mod(a: Vec4, b: Float, res: Vec4) = glm.mod(a, b, res)
        fun mod(a: Vec4d, b: Double, res: Vec4d) = glm.mod(a, b, res)
        fun mod(a: Vec4, b: Vec4, res: Vec4) = glm.mod(a, b, res)
        fun mod(a: Vec4d, b: Vec4d, res: Vec4d) = glm.mod(a, b, res)
        fun modf(a: Vec4, b: Vec4, res: Vec4) = glm.modf(a, b, res)
        fun modf(a: Vec4d, b: Vec4d, res: Vec4d) = glm.modf(a, b, res)
        fun min(a: Vec4, b: Float, res: Vec4) = glm.min(a, b, res)
        fun min(a: Vec4d, b: Double, res: Vec4d) = glm.min(a, b, res)
        fun min(a: Vec4, b: Vec4, res: Vec4) = glm.min(a, b, res)
        fun min(a: Vec4d, b: Vec4d, res: Vec4d) = glm.min(a, b, res)
        fun min(a: Vec4i, b: Int, res: Vec4i) = glm.min(a, b, res)
        fun min(a: Vec4i, b: Vec4i, res: Vec4i) = glm.min(a, b, res)
        fun max(a: Vec4, b: Float, res: Vec4) = glm.max(a, b, res)
        fun max(a: Vec4d, b: Double, res: Vec4d) = glm.max(a, b, res)
        fun max(a: Vec4, b: Vec4, res: Vec4) = glm.max(a, b, res)
        fun max(a: Vec4d, b: Vec4d, res: Vec4d) = glm.max(a, b, res)
        fun max(a: Vec4i, b: Int, res: Vec4i) = glm.max(a, b, res)
        fun max(a: Vec4i, b: Vec4i, res: Vec4i) = glm.max(a, b, res)
        fun clamp(a: Vec4, min: Float, max: Float, res: Vec4) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec4d, min: Double, max: Double, res: Vec4d) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec4, min: Vec4, max: Vec4, res: Vec4) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec4d, min: Vec4d, max: Vec4d, res: Vec4d) = glm.clamp(a, min, max, res)
        fun mix(a: Vec4, b: Vec4, interp: Float, res: Vec4) = glm.mix(a, b, interp, res)
        fun mix(a: Vec4d, b: Vec4d, interp: Double, res: Vec4d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec4, b: Vec4, interp: Boolean, res: Vec4) = glm.mix(a, b, interp, res)
        fun mix(a: Vec4d, b: Vec4d, interp: Boolean, res: Vec4d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec4, b: Vec4, interp: Vec4, res: Vec4) = glm.mix(a, b, interp, res)
        fun mix(a: Vec4d, b: Vec4d, interp: Vec4d, res: Vec4d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec4, b: Vec4, interp: Vec4bool, res: Vec4) = glm.mix(a, b, interp, res)
        fun mix(a: Vec4d, b: Vec4d, interp: Vec4bool, res: Vec4d) = glm.mix(a, b, interp, res)
        fun step(edge: Float, a: Vec4, res: Vec4) = glm.step(edge, a, res)
        fun step(edge: Double, a: Vec4d, res: Vec4d) = glm.step(edge, a, res)
        fun step(edge: Vec4, a: Vec4, res: Vec4) = glm.step(edge, a, res)
        fun step(edge: Vec4d, a: Vec4d, res: Vec4d) = glm.step(edge, a, res)
        fun smoothStep(edge0: Float, edge1: Float, a: Vec4, res: Vec4) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Double, edge1: Double, a: Vec4d, res: Vec4d) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Vec4, edge1: Vec4, a: Vec4, res: Vec4) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Vec4d, edge1: Vec4d, a: Vec4d, res: Vec4d) = glm.smoothStep(a, res)
        fun isNan(a: Vec4, res: Vec4bool) = glm.isNan(a, res)
        fun isNan(a: Vec4d, res: Vec4bool) = glm.isNan(a, res)
        fun isInf(a: Vec4, res: Vec4bool) = glm.isInf(a, res)
        fun isInf(a: Vec4d, res: Vec4bool) = glm.isInf(a, res)
        fun floatBitsToInt(a: Vec4, res: Vec4i) = glm.floatBitsToInt(a, res)
        fun floatBitsToUint(a: Vec4, res: Vec4ui) = glm.floatBitsToUint(a, res)
        fun intBitsToFloat(a: Vec4i, res: Vec4) = glm.intBitsToFloat(a, res)
        fun uintBitsToFloat(a: Vec4ui, res: Vec4) = glm.uintBitsToFloat(a, res)
        fun fma(a: Vec4, b: Vec4, c: Vec4, res: Vec4) = glm.fma(a, b, c, res)
        fun fma(a: Vec4d, b: Vec4d, c: Vec4d, res: Vec4d) = glm.fma(a, b, c, res)
        fun frexp(a: Vec4, exp: Vec4i, res: Vec4) = glm.frexp(a, exp, res)
        fun frexp(a: Vec4d, exp: Vec4i, res: Vec4d) = glm.frexp(a, exp, res)
        fun ldexp(a: Vec4, exp: Vec4i, res: Vec4) = glm.ldexp(a, exp, res)
        fun ldexp(a: Vec4d, exp: Vec4i, res: Vec4d) = glm.ldexp(a, exp, res)

        // file: func/common/func_vector2_common.kt
        fun abs(a: Vec2, res: Vec2) = glm.abs(a, res)
        fun abs(a: Vec2b, res: Vec2b) = glm.abs(a, res)
        fun abs(a: Vec2d, res: Vec2d) = glm.abs(a, res)
        fun abs(a: Vec2i, res: Vec2i) = glm.abs(a, res)
        fun abs(a: Vec2l, res: Vec2l) = glm.abs(a, res)
        fun abs(a: Vec2s, res: Vec2s) = glm.abs(a, res)
        fun sign(a: Vec2, res: Vec2) = glm.sign(a, res)
        fun sign(a: Vec2b, res: Vec2b) = glm.sign(a, res)
        fun sign(a: Vec2d, res: Vec2d) = glm.sign(a, res)
        fun sign(a: Vec2i, res: Vec2i) = glm.sign(a, res)
        fun sign(a: Vec2l, res: Vec2l) = glm.sign(a, res)
        fun sign(a: Vec2s, res: Vec2s) = glm.sign(a, res)
        fun floor(a: Vec2, res: Vec2) = glm.floor(a, res)
        fun floor(a: Vec2d, res: Vec2d) = glm.floor(a, res)
        fun trunc(a: Vec2, res: Vec2) = glm.trunc(a, res)
        fun trunc(a: Vec2d, res: Vec2d) = glm.trunc(a, res)
        fun round(a: Vec2, res: Vec2) = glm.round(a, res)
        fun round(a: Vec2d, res: Vec2d) = glm.round(a, res)
        fun ceil(a: Vec2, res: Vec2) = glm.ceil(a, res)
        fun ceil(a: Vec2d, res: Vec2d) = glm.ceil(a, res)
        fun fract(a: Vec2, res: Vec2) = glm.fract(a, res)
        fun fract(a: Vec2d, res: Vec2d) = glm.fract(a, res)
        fun mod(a: Vec2, b: Float, res: Vec2) = glm.mod(a, b, res)
        fun mod(a: Vec2d, b: Double, res: Vec2d) = glm.mod(a, b, res)
        fun mod(a: Vec2, b: Vec2, res: Vec2) = glm.mod(a, b, res)
        fun mod(a: Vec2d, b: Vec2d, res: Vec2d) = glm.mod(a, b, res)
        fun min(a: Vec2, b: Float, res: Vec2) = glm.min(a, b, res)
        fun min(a: Vec2d, b: Double, res: Vec2d) = glm.min(a, b, res)
        fun min(a: Vec2, b: Vec2, res: Vec2) = glm.min(a, b, res)
        fun min(a: Vec2d, b: Vec2d, res: Vec2d) = glm.min(a, b, res)
        fun min(a: Vec2i, b: Int, res: Vec2i) = glm.min(a, b, res)
        fun min(a: Vec2i, b: Vec2i, res: Vec2i) = glm.min(a, b, res)
        fun min(a: Vec2b, b: Byte, res: Vec2b) = glm.min(a, b, res)
        fun min(a: Vec2b, b: Vec2b, res: Vec2b) = glm.min(a, b, res)
        fun max(a: Vec2, b: Float, res: Vec2) = glm.max(a, b, res)
        fun max(a: Vec2d, b: Double, res: Vec2d) = glm.max(a, b, res)
        fun max(a: Vec2, b: Vec2, res: Vec2) = glm.max(a, b, res)
        fun max(a: Vec2d, b: Vec2d, res: Vec2d) = glm.max(a, b, res)
        fun max(a: Vec2i, b: Int, res: Vec2i) = glm.max(a, b, res)
        fun max(a: Vec2i, b: Vec2i, res: Vec2i) = glm.max(a, b, res)
        fun max(a: Vec2b, b: Byte, res: Vec2b) = glm.max(a, b, res)
        fun max(a: Vec2b, b: Vec2b, res: Vec2b) = glm.max(a, b, res)
        fun clamp(a: Vec2, min: Float, max: Float, res: Vec2) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec2d, min: Double, max: Double, res: Vec2d) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec2, min: Vec2, max: Vec2, res: Vec2) = glm.clamp(a, min, max, res)
        fun clamp(a: Vec2d, min: Vec2d, max: Vec2d, res: Vec2d) = glm.clamp(a, min, max, res)
        fun mix(a: Vec2, b: Vec2, interp: Float, res: Vec2) = glm.mix(a, b, interp, res)
        fun mix(a: Vec2d, b: Vec2d, interp: Double, res: Vec2d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec2, b: Vec2, interp: Boolean, res: Vec2) = glm.mix(a, b, interp, res)
        fun mix(a: Vec2d, b: Vec2d, interp: Boolean, res: Vec2d) = glm.mix(a, b, interp, res)
        fun mix(a: Vec2, b: Vec2, interp: Vec2, res: Vec2) = glm.mix(a, b, interp, res)
        fun mix(a: Vec2d, b: Vec2d, interp: Vec2d, res: Vec2d = Vec2d()) = glm.mix(a: Vec2d, b: Vec2d, interp: Vec2d, res: Vec2d = Vec2d()
        fun mix(a: Vec2, b: Vec2, interp: Vec2bool, res: Vec2) = glm.mix(a, b, interp, res)
        fun mix(a: Vec2d, b: Vec2d, interp: Vec2bool, res: Vec2d) = glm.mix(a, b, interp, res)
        fun step(edge: Float, a: Vec2, res: Vec2) = glm.step(edge, a, res)
        fun step(edge: Double, a: Vec2d, res: Vec2d) = glm.step(edge, a, res)
        fun step(edge: Vec2, a: Vec2, res: Vec2) = glm.step(edge, a, res)
        fun step(edge: Vec2d, a: Vec2d, res: Vec2d) = glm.step(edge, a, res)
        fun smoothStep(edge0: Float, edge1: Float, a: Vec2, res: Vec2) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Double, edge1: Double, a: Vec2d, res: Vec2d) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Vec2, edge1: Vec2, a: Vec2, res: Vec2) = glm.smoothStep(a, res)
        fun smoothStep(edge0: Vec2d, edge1: Vec2d, a: Vec2d, res: Vec2d) = glm.smoothStep(a, res)
        fun isNan(a: Vec2, res: Vec2bool) = glm.isNan(a, res)
        fun isNan(a: Vec2d, res: Vec2bool) = glm.isNan(a, res)
        fun isInf(a: Vec2, res: Vec2bool) = glm.isInf(a, res)
        fun isInf(a: Vec2d, res: Vec2bool) = glm.isInf(a, res)
        fun floatBitsToInt(a: Vec2, res: Vec2i) = glm.floatBitsToInt(a, res)
        fun floatBitsToUint(a: Vec2, res: Vec2ui) = glm.floatBitsToUint(a, res)
        fun intBitsToFloat(a: Vec2i, res: Vec2) = glm.intBitsToFloat(a, res)
        fun uintBitsToFloat(a: Vec2ui, res: Vec2) = glm.uintBitsToFloat(a, res)
        fun fma(a: Vec2, b: Vec2, c: Vec2, res: Vec2) = glm.fma(a, b, c, res)
        fun fma(a: Vec2d, b: Vec2d, c: Vec2d, res: Vec2d) = glm.fma(a, b, c, res)
        fun frexp(a: Vec2, exp: Vec2i, res: Vec2) = glm.frexp(a, exp, res)
        fun frexp(a: Vec2d, exp: Vec2i, res: Vec2d) = glm.frexp(a, exp, res)
        fun ldexp(a: Vec2, exp: Vec2i, res: Vec2) = glm.ldexp(a, exp, res)
        fun ldexp(a: Vec2d, exp: Vec2i, res: Vec2d) = glm.ldexp(a, exp, res)

        // file: func/common/func_common.kt
        fun modf(a: Float, b: KMutableProperty0<Float>) = glm.modf(a, b)
        fun modf(a: Double, b: KMutableProperty0<Double>) = glm.modf(a, b)
        fun smoothStep(edge0: Float, edge1: Float, a: Float) = glm.smoothStep(a)
        fun smoothStep(edge0: Double, edge1: Double, a: Double) = glm.smoothStep(a)
        fun frexp(a: Float, exp: KMutableProperty0<Int>) = glm.frexp(a, exp)
        fun frexp(a: Double, exp: KMutableProperty0<Int>) = glm.frexp(a, exp)

        // file: func/func_vec_relational.kt
        fun lessThan(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()) = glm.lessThan(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()
        fun lessThanEqual(a: Vec1t<out Number>, b: Number, res: Vec1bool = Vec1bool()) = glm.lessThanEqual(a: Vec1t<out Number>, b: Number, res: Vec1bool = Vec1bool()
        fun lessThanEqual(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()) = glm.lessThanEqual(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()
        fun greaterThan(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()) = glm.greaterThan(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()
        fun greaterThanEqual(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()) = glm.greaterThanEqual(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()
        fun equal(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()) = glm.equal(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()
        fun notEqual(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()) = glm.notEqual(a: Vec1t<out Number>, b: Vec1t<out Number>, res: Vec1bool = Vec1bool()
        fun isEqual(a: Vec1t<out Number>, b: Vec1t<out Number>) = glm.isEqual(a, b)
        fun not(a: Vec1bool, res: Vec1bool = Vec1bool()) = glm.not(a: Vec1bool, res: Vec1bool = Vec1bool()
        fun lessThan(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()) = glm.lessThan(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()
        fun lessThanEqual(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()) = glm.lessThanEqual(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()
        fun greaterThan(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()) = glm.greaterThan(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()
        fun greaterThanEqual(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()) = glm.greaterThanEqual(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()
        fun equal(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()) = glm.equal(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()
        fun notEqual(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()) = glm.notEqual(a: Vec2t<out Number>, b: Vec2t<out Number>, res: Vec2bool = Vec2bool()
        fun isEqual(a: Vec2t<out Number>, b: Vec2t<out Number>) = glm.isEqual(a, b)
        fun not(a: Vec2bool, res: Vec2bool = Vec2bool()) = glm.not(a: Vec2bool, res: Vec2bool = Vec2bool()
        fun lessThan(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()) = glm.lessThan(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()
        fun lessThanEqual(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()) = glm.lessThanEqual(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()
        fun greaterThan(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()) = glm.greaterThan(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()
        fun greaterThanEqual(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()) = glm.greaterThanEqual(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()
        fun equal(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()) = glm.equal(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()
        fun notEqual(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()) = glm.notEqual(a: Vec3t<out Number>, b: Vec3t<out Number>, res: Vec3bool = Vec3bool()
        fun isEqual(a: Vec3t<out Number>, b: Vec3t<out Number>) = glm.isEqual(a, b)
        fun not(a: Vec3bool, res: Vec3bool = Vec3bool()) = glm.not(a: Vec3bool, res: Vec3bool = Vec3bool()
        fun lessThan(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()) = glm.lessThan(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()
        fun lessThanEqual(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()) = glm.lessThanEqual(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()
        fun greaterThan(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()) = glm.greaterThan(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()
        fun greaterThanEqual(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()) = glm.greaterThanEqual(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()
        fun equal(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()) = glm.equal(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()
        fun notEqual(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()) = glm.notEqual(a: Vec4t<out Number>, b: Vec4t<out Number>, res: Vec4bool = Vec4bool()
        fun isEqual(a: Vec4t<out Number>, b: Vec4t<out Number>) = glm.isEqual(a, b)
        fun not(a: Vec4bool, res: Vec4bool = Vec4bool()) = glm.not(a: Vec4bool, res: Vec4bool = Vec4bool()
        fun equal(a: Vec2bool, b: Vec2bool, res: Vec2bool = Vec2bool()) = glm.equal(a: Vec2bool, b: Vec2bool, res: Vec2bool = Vec2bool()
        fun notEqual(a: Vec2bool, b: Vec2bool, res: Vec2bool = Vec2bool()) = glm.notEqual(a: Vec2bool, b: Vec2bool, res: Vec2bool = Vec2bool()
        fun equal(a: Vec3bool, b: Vec3bool, res: Vec3bool = Vec3bool()) = glm.equal(a: Vec3bool, b: Vec3bool, res: Vec3bool = Vec3bool()
        fun notEqual(a: Vec3bool, b: Vec3bool, res: Vec3bool = Vec3bool()) = glm.notEqual(a: Vec3bool, b: Vec3bool, res: Vec3bool = Vec3bool()
        fun equal(a: Vec4bool, b: Vec4bool, res: Vec4bool = Vec4bool()) = glm.equal(a: Vec4bool, b: Vec4bool, res: Vec4bool = Vec4bool()
        fun notEqual(a: Vec4bool, b: Vec4bool, res: Vec4bool = Vec4bool()) = glm.notEqual(a: Vec4bool, b: Vec4bool, res: Vec4bool = Vec4bool()

        // file: func/funcInteger.kt
        fun bitfieldExtract(value: uint, offset: Int, bits: Int) = glm.bitfieldExtract(value, offset, bits)
        fun bitfieldInsert(base: uint, insert: uint, offset: Int, bits: Int) = glm.bitfieldInsert(base, insert, offset, bits)
        fun bitfieldReverse(v: uint) = glm.bitfieldReverse(v)
        fun bitfieldReverse(v: ulong) = glm.bitfieldReverse(v)
        fun compute_bitfieldReverseStep(v: uint, mask: ulong, shift: uint) = glm.compute_bitfieldReverseStep(v, mask, shift)
        fun compute_bitfieldReverseStep(v: ulong, mask: ulong, shift: uint) = glm.compute_bitfieldReverseStep(v, mask, shift)

        // file: closestPointToLines.kt
        fun closestPointToLines(lines: Array<FloatArray>) = glm.closestPointToLines(lines)

        // file: vec1/Vec1b.kt
        fun invoke(x: Byte) = glm.invoke(x)
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec1/operators/vec1i_operators.kt
        fun plus(res: Vec1i, a: Vec1i, bX: Int) = glm.plus(res, a)
        fun minus(res: Vec1i, a: Vec1i, bX: Int) = glm.minus(res, a)
        fun minus(res: Vec1i, aX: Int, b: Vec1i) = glm.minus(res, b)
        fun times(res: Vec1i, a: Vec1i, bX: Int) = glm.times(res, a)
        fun div(res: Vec1i, a: Vec1i, bX: Int) = glm.div(res, a)
        fun div(res: Vec1i, aX: Int, b: Vec1i) = glm.div(res, b)
        fun rem(res: Vec1i, a: Vec1i, bX: Int) = glm.rem(res, a)
        fun rem(res: Vec1i, aX: Int, b: Vec1i) = glm.rem(res, b)
        fun and(res: Vec1i, a: Vec1i, bX: Int) = glm.and(res, a)
        fun or(res: Vec1i, a: Vec1i, bX: Int) = glm.or(res, a)
        fun xor(res: Vec1i, a: Vec1i, bX: Int) = glm.xor(res, a)
        fun shl(res: Vec1i, a: Vec1i, bX: Int) = glm.shl(res, a)
        fun shr(res: Vec1i, a: Vec1i, bX: Int) = glm.shr(res, a)
        fun inv(res: Vec1i, a: Vec1i) = glm.inv(res, a)

        // file: vec1/operators/vec1_operators.kt
        fun plus(res: Vec1, a: Vec1, bX: Float) = glm.plus(res, a)
        fun minus(res: Vec1, a: Vec1, bX: Float) = glm.minus(res, a)
        fun minus(res: Vec1, aX: Float, b: Vec1) = glm.minus(res, b)
        fun times(res: Vec1, a: Vec1, bX: Float) = glm.times(res, a)
        fun div(res: Vec1, a: Vec1, bX: Float) = glm.div(res, a)
        fun div(res: Vec1, aX: Float, b: Vec1) = glm.div(res, b)
        fun rem(res: Vec1, a: Vec1, bX: Float) = glm.rem(res, a)
        fun rem(res: Vec1, aX: Float, b: Vec1) = glm.rem(res, b)

        // file: vec1/operators/vec1d_operators.kt
        fun plus(res: Vec1d, a: Vec1d, bX: Double) = glm.plus(res, a)
        fun minus(res: Vec1d, a: Vec1d, bX: Double) = glm.minus(res, a)
        fun minus(res: Vec1d, aX: Double, b: Vec1d) = glm.minus(res, b)
        fun times(res: Vec1d, a: Vec1d, bX: Double) = glm.times(res, a)
        fun div(res: Vec1d, a: Vec1d, bX: Double) = glm.div(res, a)
        fun div(res: Vec1d, aX: Double, b: Vec1d) = glm.div(res, b)
        fun rem(res: Vec1d, a: Vec1d, bX: Double) = glm.rem(res, a)
        fun rem(res: Vec1d, aX: Double, b: Vec1d) = glm.rem(res, b)

        // file: vec1/Vec1bool.kt
        fun get(i: Int) = glm.get(i)
        fun put(b: Boolean) = glm.put(b)
        fun put(ba: BooleanArray) = glm.put(ba)
        fun put(ba: Array<Boolean>) = glm.put(ba)
        fun to(floats: BooleanArray) = glm.to(floats)
        fun to(floats: BooleanArray, index: Int) = glm.to(floats, index)
        fun not(res: Vec1bool) = glm.not(res)

        // file: vec1/Vec1.kt
        fun invoke(x: Float) = glm.invoke(x)
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec1/Vec1us.kt
        fun invoke(x: Ushort) = glm.invoke(x)
        fun invoke(x: Short) = glm.invoke(x)
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(shorts: ShortArray) = glm.to(shorts)
        fun to(shorts: ShortArray, index: Int) = glm.to(shorts, index)
        fun toShortBuffer(stack: MemoryStack) = glm.toShortBuffer(stack)
        fun to(buf: ShortBuffer) = glm.to(buf)
        fun to(buf: ShortBuffer, index: Int) = glm.to(buf, index)

        // file: vec1/Vec1s.kt
        fun invoke(x: Short) = glm.invoke(x)
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(shorts: ShortArray) = glm.to(shorts)
        fun to(shorts: ShortArray, index: Int) = glm.to(shorts, index)
        fun toShortBuffer(stack: MemoryStack) = glm.toShortBuffer(stack)
        fun to(buf: ShortBuffer) = glm.to(buf)
        fun to(buf: ShortBuffer, index: Int) = glm.to(buf, index)

        // file: vec1/Vec1ub.kt
        fun invoke(x: Ubyte) = glm.invoke(x)
        fun invoke(x: Byte) = glm.invoke(x)
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec1/Vec1ui.kt
        fun invoke(x: Uint) = glm.invoke(x)
        fun invoke(x: Int) = glm.invoke(x)
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(ints: IntArray) = glm.to(ints)
        fun to(ints: IntArray, index: Int) = glm.to(ints, index)
        fun toIntBuffer(stack: MemoryStack) = glm.toIntBuffer(stack)
        fun to(buf: IntBuffer) = glm.to(buf)
        fun to(buf: IntBuffer, index: Int) = glm.to(buf, index)

        // file: vec1/Vec1i.kt
        fun invoke(x: Int) = glm.invoke(x)
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(ints: IntArray) = glm.to(ints)
        fun to(ints: IntArray, index: Int) = glm.to(ints, index)
        fun toIntBuffer(stack: MemoryStack) = glm.toIntBuffer(stack)
        fun to(buf: IntBuffer) = glm.to(buf)
        fun to(buf: IntBuffer, index: Int) = glm.to(buf, index)

        // file: vec1/Vec1t.kt
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray) = glm.to(bytes)
        fun to(bytes: ByteArray, bigEndian: Boolean) = glm.to(bytes, ndian)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean = true) = glm.to(bytes, index, ndian)

        // file: vec1/Vec1d.kt
        fun invoke(x: Double) = glm.invoke(x)
        fun invoke(x: Number) = glm.invoke(x)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)

        // file: mat2x4/Mat2x4d.kt
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)

        // file: mat2x4/Mat2x4t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: mat2x4/Mat2x4.kt
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec2/Vec2ul.kt
        fun invoke(x: Ulong, y: Ulong) = glm.invoke(x, y)
        fun invoke(x: Long, y: Long) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(longs: LongArray) = glm.to(longs)
        fun to(longs: LongArray, index: Int) = glm.to(longs, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toLongBuffer(stack: MemoryStack) = glm.toLongBuffer(stack)
        fun to(buf: LongBuffer) = glm.to(buf)
        fun to(buf: LongBuffer, index: Int) = glm.to(buf, index)

        // file: vec2/Vec2ui.kt
        fun invoke(x: Uint, y: Uint) = glm.invoke(x, y)
        fun invoke(x: Int, y: Int) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(ints: IntArray) = glm.to(ints)
        fun to(ints: IntArray, index: Int) = glm.to(ints, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toIntBuffer(stack: MemoryStack) = glm.toIntBuffer(stack)
        fun to(buf: IntBuffer) = glm.to(buf)
        fun to(buf: IntBuffer, index: Int) = glm.to(buf, index)

        // file: vec2/operators/opVec2d.kt
        fun plus(res: Vec2d, a: Vec2d, bX: Double, bY: Double) = glm.plus(res, a)
        fun minus(res: Vec2d, a: Vec2d, bX: Double, bY: Double) = glm.minus(res, a)
        fun minus(res: Vec2d, aX: Double, aY: Double, b: Vec2d) = glm.minus(res, b)
        fun times(res: Vec2d, a: Vec2d, bX: Double, bY: Double) = glm.times(res, a)
        fun div(res: Vec2d, a: Vec2d, bX: Double, bY: Double) = glm.div(res, a)
        fun div(res: Vec2d, aX: Double, aY: Double, b: Vec2d) = glm.div(res, b)
        fun rem(res: Vec2d, a: Vec2d, bX: Double, bY: Double) = glm.rem(res, a)
        fun rem(res: Vec2d, aX: Double, aY: Double, b: Vec2d) = glm.rem(res, b)

        // file: vec2/operators/opVec2us.kt
        fun plus(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.plus(res, a)
        fun plus(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.plus(res, a)
        fun plus(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.plus(res, a)
        fun minus(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.minus(res, a)
        fun minus(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.minus(res, a)
        fun minus(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.minus(res, a)
        fun minus(res: Vec2us, aX: Ushort, aY: Ushort, b: Vec2us) = glm.minus(res, b)
        fun minus(res: Vec2us, aX: Short, aY: Short, b: Vec2us) = glm.minus(res, b)
        fun minus(res: Vec2us, aX: Int, aY: Int, b: Vec2us) = glm.minus(res, b)
        fun times(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.times(res, a)
        fun times(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.times(res, a)
        fun times(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.times(res, a)
        fun div(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.div(res, a)
        fun div(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.div(res, a)
        fun div(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.div(res, a)
        fun div(res: Vec2us, aX: Ushort, aY: Ushort, b: Vec2us) = glm.div(res, b)
        fun div(res: Vec2us, aX: Short, aY: Short, b: Vec2us) = glm.div(res, b)
        fun div(res: Vec2us, aX: Int, aY: Int, b: Vec2us) = glm.div(res, b)
        fun rem(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.rem(res, a)
        fun rem(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.rem(res, a)
        fun rem(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.rem(res, a)
        fun rem(res: Vec2us, aX: Ushort, aY: Ushort, b: Vec2us) = glm.rem(res, b)
        fun rem(res: Vec2us, aX: Short, aY: Short, b: Vec2us) = glm.rem(res, b)
        fun rem(res: Vec2us, aX: Int, aY: Int, b: Vec2us) = glm.rem(res, b)
        fun and(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.and(res, a)
        fun and(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.and(res, a)
        fun and(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.and(res, a)
        fun or(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.or(res, a)
        fun or(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.or(res, a)
        fun or(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.or(res, a)
        fun xor(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.xor(res, a)
        fun xor(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.xor(res, a)
        fun xor(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.xor(res, a)
        fun shl(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.shl(res, a)
        fun shl(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.shl(res, a)
        fun shl(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.shl(res, a)
        fun shr(res: Vec2us, a: Vec2us, bX: Ushort, bY: Ushort) = glm.shr(res, a)
        fun shr(res: Vec2us, a: Vec2us, bX: Short, bY: Short) = glm.shr(res, a)
        fun shr(res: Vec2us, a: Vec2us, bX: Int, bY: Int) = glm.shr(res, a)
        fun inv(res: Vec2us, a: Vec2us) = glm.inv(res, a)

        // file: vec2/operators/opVec2s.kt
        fun plus(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.plus(res, a)
        fun plus(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.plus(res, a)
        fun minus(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.minus(res, a)
        fun minus(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.minus(res, a)
        fun minus(res: Vec2s, aX: Short, aY: Short, b: Vec2s) = glm.minus(res, b)
        fun minus(res: Vec2s, aX: Int, aY: Int, b: Vec2s) = glm.minus(res, b)
        fun times(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.times(res, a)
        fun times(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.times(res, a)
        fun div(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.div(res, a)
        fun div(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.div(res, a)
        fun div(res: Vec2s, aX: Short, aY: Short, b: Vec2s) = glm.div(res, b)
        fun div(res: Vec2s, aX: Int, aY: Int, b: Vec2s) = glm.div(res, b)
        fun rem(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.rem(res, a)
        fun rem(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.rem(res, a)
        fun rem(res: Vec2s, aX: Short, aY: Short, b: Vec2s) = glm.rem(res, b)
        fun rem(res: Vec2s, aX: Int, aY: Int, b: Vec2s) = glm.rem(res, b)
        fun and(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.and(res, a)
        fun and(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.and(res, a)
        fun or(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.or(res, a)
        fun or(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.or(res, a)
        fun xor(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.xor(res, a)
        fun xor(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.xor(res, a)
        fun shl(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.shl(res, a)
        fun shl(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.shl(res, a)
        fun shr(res: Vec2s, a: Vec2s, bX: Short, bY: Short) = glm.shr(res, a)
        fun shr(res: Vec2s, a: Vec2s, bX: Int, bY: Int) = glm.shr(res, a)
        fun inv(res: Vec2s, a: Vec2s) = glm.inv(res, a)

        // file: vec2/operators/opVec2.kt
        fun plus(res: Vec2, a: Vec2, bX: Float, bY: Float) = glm.plus(res, a)
        fun minus(res: Vec2, a: Vec2, bX: Float, bY: Float) = glm.minus(res, a)
        fun minus(res: Vec2, aX: Float, aY: Float, b: Vec2) = glm.minus(res, b)
        fun times(res: Vec2, a: Vec2, bX: Float, bY: Float) = glm.times(res, a)
        fun div(res: Vec2, a: Vec2, bX: Float, bY: Float) = glm.div(res, a)
        fun div(res: Vec2, aX: Float, aY: Float, b: Vec2) = glm.div(res, b)
        fun rem(res: Vec2, a: Vec2, bX: Float, bY: Float) = glm.rem(res, a)
        fun rem(res: Vec2, aX: Float, aY: Float, b: Vec2) = glm.rem(res, b)

        // file: vec2/operators/opVec2ui.kt
        fun plus(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.plus(res, a)
        fun plus(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.plus(res, a)
        fun minus(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.minus(res, a)
        fun minus(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.minus(res, a)
        fun minus(res: Vec2ui, aX: Uint, aY: Uint, b: Vec2ui) = glm.minus(res, b)
        fun minus(res: Vec2ui, aX: Int, aY: Int, b: Vec2ui) = glm.minus(res, b)
        fun times(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.times(res, a)
        fun times(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.times(res, a)
        fun div(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.div(res, a)
        fun div(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.div(res, a)
        fun div(res: Vec2ui, aX: Uint, aY: Uint, b: Vec2ui) = glm.div(res, b)
        fun div(res: Vec2ui, aX: Int, aY: Int, b: Vec2ui) = glm.div(res, b)
        fun rem(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.rem(res, a)
        fun rem(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.rem(res, a)
        fun rem(res: Vec2ui, aX: Uint, aY: Uint, b: Vec2ui) = glm.rem(res, b)
        fun rem(res: Vec2ui, aX: Int, aY: Int, b: Vec2ui) = glm.rem(res, b)
        fun and(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.and(res, a)
        fun and(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.and(res, a)
        fun or(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.or(res, a)
        fun or(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.or(res, a)
        fun xor(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.xor(res, a)
        fun xor(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.xor(res, a)
        fun shl(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.shl(res, a)
        fun shl(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.shl(res, a)
        fun shr(res: Vec2ui, a: Vec2ui, bX: Uint, bY: Uint) = glm.shr(res, a)
        fun shr(res: Vec2ui, a: Vec2ui, bX: Int, bY: Int) = glm.shr(res, a)
        fun inv(res: Vec2ui, a: Vec2ui) = glm.inv(res, a)

        // file: vec2/operators/opVec2b.kt
        fun plus(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.plus(res, a)
        fun plus(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.plus(res, a)
        fun minus(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.minus(res, a)
        fun minus(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.minus(res, a)
        fun minus(res: Vec2b, aX: Byte, aY: Byte, b: Vec2b) = glm.minus(res, b)
        fun minus(res: Vec2b, aX: Int, aY: Int, b: Vec2b) = glm.minus(res, b)
        fun times(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.times(res, a)
        fun times(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.times(res, a)
        fun div(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.div(res, a)
        fun div(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.div(res, a)
        fun div(res: Vec2b, aX: Byte, aY: Byte, b: Vec2b) = glm.div(res, b)
        fun div(res: Vec2b, aX: Int, aY: Int, b: Vec2b) = glm.div(res, b)
        fun rem(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.rem(res, a)
        fun rem(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.rem(res, a)
        fun rem(res: Vec2b, aX: Byte, aY: Byte, b: Vec2b) = glm.rem(res, b)
        fun rem(res: Vec2b, aX: Int, aY: Int, b: Vec2b) = glm.rem(res, b)
        fun and(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.and(res, a)
        fun and(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.and(res, a)
        fun or(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.or(res, a)
        fun or(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.or(res, a)
        fun xor(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.xor(res, a)
        fun xor(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.xor(res, a)
        fun shl(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.shl(res, a)
        fun shl(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.shl(res, a)
        fun shr(res: Vec2b, a: Vec2b, bX: Byte, bY: Byte) = glm.shr(res, a)
        fun shr(res: Vec2b, a: Vec2b, bX: Int, bY: Int) = glm.shr(res, a)
        fun inv(res: Vec2b, a: Vec2b) = glm.inv(res, a)

        // file: vec2/operators/opVec2ul.kt
        fun plus(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.plus(res, a)
        fun plus(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.plus(res, a)
        fun plus(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.plus(res, a)
        fun minus(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.minus(res, a)
        fun minus(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.minus(res, a)
        fun minus(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.minus(res, a)
        fun minus(res: Vec2ul, aX: Int, aY: Int, b: Vec2ul) = glm.minus(res, b)
        fun minus(res: Vec2ul, aX: Ulong, aY: Ulong, b: Vec2ul) = glm.minus(res, b)
        fun minus(res: Vec2ul, aX: Long, aY: Long, b: Vec2ul) = glm.minus(res, b)
        fun times(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.times(res, a)
        fun times(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.times(res, a)
        fun times(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.times(res, a)
        fun div(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.div(res, a)
        fun div(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.div(res, a)
        fun div(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.div(res, a)
        fun div(res: Vec2ul, aX: Int, aY: Int, b: Vec2ul) = glm.div(res, b)
        fun div(res: Vec2ul, aX: Ulong, aY: Ulong, b: Vec2ul) = glm.div(res, b)
        fun div(res: Vec2ul, aX: Long, aY: Long, b: Vec2ul) = glm.div(res, b)
        fun rem(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.rem(res, a)
        fun rem(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.rem(res, a)
        fun rem(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.rem(res, a)
        fun rem(res: Vec2ul, aX: Int, aY: Int, b: Vec2ul) = glm.rem(res, b)
        fun rem(res: Vec2ul, aX: Ulong, aY: Ulong, b: Vec2ul) = glm.rem(res, b)
        fun rem(res: Vec2ul, aX: Long, aY: Long, b: Vec2ul) = glm.rem(res, b)
        fun and(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.and(res, a)
        fun and(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.and(res, a)
        fun and(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.and(res, a)
        fun or(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.or(res, a)
        fun or(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.or(res, a)
        fun or(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.or(res, a)
        fun xor(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.xor(res, a)
        fun xor(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.xor(res, a)
        fun xor(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.xor(res, a)
        fun shl(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.shl(res, a)
        fun shl(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.shl(res, a)
        fun shl(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.shl(res, a)
        fun shr(res: Vec2ul, a: Vec2ul, bX: Int, bY: Int) = glm.shr(res, a)
        fun shr(res: Vec2ul, a: Vec2ul, bX: Ulong, bY: Ulong) = glm.shr(res, a)
        fun shr(res: Vec2ul, a: Vec2ul, bX: Long, bY: Long) = glm.shr(res, a)
        fun inv(res: Vec2ul, a: Vec2ul) = glm.inv(res, a)

        // file: vec2/operators/opVec2ub.kt
        fun plus(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.plus(res, a)
        fun plus(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.plus(res, a)
        fun plus(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.plus(res, a)
        fun minus(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.minus(res, a)
        fun minus(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.minus(res, a)
        fun minus(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.minus(res, a)
        fun minus(res: Vec2ub, aX: Ubyte, aY: Ubyte, b: Vec2ub) = glm.minus(res, b)
        fun minus(res: Vec2ub, aX: Byte, aY: Byte, b: Vec2ub) = glm.minus(res, b)
        fun minus(res: Vec2ub, aX: Int, aY: Int, b: Vec2ub) = glm.minus(res, b)
        fun times(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.times(res, a)
        fun times(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.times(res, a)
        fun times(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.times(res, a)
        fun div(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.div(res, a)
        fun div(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.div(res, a)
        fun div(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.div(res, a)
        fun div(res: Vec2ub, aX: Ubyte, aY: Ubyte, b: Vec2ub) = glm.div(res, b)
        fun div(res: Vec2ub, aX: Byte, aY: Byte, b: Vec2ub) = glm.div(res, b)
        fun div(res: Vec2ub, aX: Int, aY: Int, b: Vec2ub) = glm.div(res, b)
        fun rem(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.rem(res, a)
        fun rem(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.rem(res, a)
        fun rem(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.rem(res, a)
        fun rem(res: Vec2ub, aX: Ubyte, aY: Ubyte, b: Vec2ub) = glm.rem(res, b)
        fun rem(res: Vec2ub, aX: Byte, aY: Byte, b: Vec2ub) = glm.rem(res, b)
        fun rem(res: Vec2ub, aX: Int, aY: Int, b: Vec2ub) = glm.rem(res, b)
        fun and(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.and(res, a)
        fun and(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.and(res, a)
        fun and(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.and(res, a)
        fun or(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.or(res, a)
        fun or(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.or(res, a)
        fun or(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.or(res, a)
        fun xor(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.xor(res, a)
        fun xor(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.xor(res, a)
        fun xor(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.xor(res, a)
        fun shl(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.shl(res, a)
        fun shl(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.shl(res, a)
        fun shl(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.shl(res, a)
        fun shr(res: Vec2ub, a: Vec2ub, bX: Ubyte, bY: Ubyte) = glm.shr(res, a)
        fun shr(res: Vec2ub, a: Vec2ub, bX: Byte, bY: Byte) = glm.shr(res, a)
        fun shr(res: Vec2ub, a: Vec2ub, bX: Int, bY: Int) = glm.shr(res, a)
        fun inv(res: Vec2ub, a: Vec2ub) = glm.inv(res, a)

        // file: vec2/operators/opVec2l.kt
        fun plus(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.plus(res, a)
        fun plus(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.plus(res, a)
        fun minus(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.minus(res, a)
        fun minus(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.minus(res, a)
        fun minus(res: Vec2l, aX: Int, aY: Int, b: Vec2l) = glm.minus(res, b)
        fun minus(res: Vec2l, aX: Long, aY: Long, b: Vec2l) = glm.minus(res, b)
        fun times(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.times(res, a)
        fun times(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.times(res, a)
        fun div(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.div(res, a)
        fun div(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.div(res, a)
        fun div(res: Vec2l, aX: Int, aY: Int, b: Vec2l) = glm.div(res, b)
        fun div(res: Vec2l, aX: Long, aY: Long, b: Vec2l) = glm.div(res, b)
        fun rem(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.rem(res, a)
        fun rem(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.rem(res, a)
        fun rem(res: Vec2l, aX: Int, aY: Int, b: Vec2l) = glm.rem(res, b)
        fun rem(res: Vec2l, aX: Long, aY: Long, b: Vec2l) = glm.rem(res, b)
        fun and(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.and(res, a)
        fun and(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.and(res, a)
        fun or(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.or(res, a)
        fun or(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.or(res, a)
        fun xor(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.xor(res, a)
        fun xor(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.xor(res, a)
        fun shl(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.shl(res, a)
        fun shl(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.shl(res, a)
        fun shr(res: Vec2l, a: Vec2l, bX: Long, bY: Long) = glm.shr(res, a)
        fun shr(res: Vec2l, a: Vec2l, bX: Int, bY: Int) = glm.shr(res, a)
        fun inv(res: Vec2l, a: Vec2l) = glm.inv(res, a)

        // file: vec2/operators/opVec2i.kt
        fun plus(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.plus(res, a)
        fun minus(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.minus(res, a)
        fun minus(res: Vec2i, aX: Int, aY: Int, b: Vec2i) = glm.minus(res, b)
        fun times(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.times(res, a)
        fun div(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.div(res, a)
        fun div(res: Vec2i, aX: Int, aY: Int, b: Vec2i) = glm.div(res, b)
        fun rem(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.rem(res, a)
        fun rem(res: Vec2i, aX: Int, aY: Int, b: Vec2i) = glm.rem(res, b)
        fun and(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.and(res, a)
        fun or(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.or(res, a)
        fun xor(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.xor(res, a)
        fun shl(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.shl(res, a)
        fun shr(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.shr(res, a)
        fun ushr(res: Vec2i, a: Vec2i, bX: Int, bY: Int) = glm.ushr(res, a)
        fun inv(res: Vec2i, a: Vec2i) = glm.inv(res, a)

        // file: vec2/Vec2.kt
        fun invoke(x: Float, y: Float) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)
        fun max(b: Vec2t<*>) = glm.max(b)
        fun max(b: Number) = glm.max(b)
        fun min(b: Vec2t<*>) = glm.min(b)
        fun min(b: Number) = glm.min(b)
        fun negate(res: Vec2 = Vec2()) = glm.negate(res: Vec2 = Vec2()

        // file: vec2/Vec2d.kt
        fun invoke(x: Double, y: Double) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)
        fun negate(res: Vec2d = Vec2d()) = glm.negate(res: Vec2d = Vec2d()

        // file: vec2/Vec2i.kt
        fun invoke(x: Int, y: Int) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(ints: IntArray) = glm.to(ints)
        fun to(ints: IntArray, index: Int) = glm.to(ints, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toIntBuffer(stack: MemoryStack) = glm.toIntBuffer(stack)
        fun to(buf: IntBuffer) = glm.to(buf)
        fun to(buf: IntBuffer, index: Int) = glm.to(buf, index)

        // file: vec2/Vec2b.kt
        fun invoke(x: Byte, y: Byte) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec2/Vec2t.kt
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun toByteArray(bigEndian: Boolean = true) = glm.toByteArray(ndian)
        fun to(bytes: ByteArray) = glm.to(bytes)
        fun to(bytes: ByteArray, bigEndian: Boolean) = glm.to(bytes, ndian)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean = true) = glm.to(bytes, index, ndian)
        fun createInstance(x: T, y: T) = glm.createInstance(x, y)

        // file: vec2/Vec2bool.kt
        fun get(i: Int) = glm.get(i)
        fun put(b: Boolean) = glm.put(b)
        fun put(x: Boolean, y: Boolean) = glm.put(x, y)
        fun put(ba: BooleanArray) = glm.put(ba)
        fun put(ba: Array<Boolean>) = glm.put(ba)
        fun not(res: Vec2bool) = glm.not(res)

        // file: vec2/Vec2ub.kt
        fun invoke(x: Ubyte, y: Ubyte) = glm.invoke(x, y)
        fun invoke(x: Byte, y: Byte) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec2/Vec2l.kt
        fun invoke(x: Long, y: Long) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(longs: LongArray) = glm.to(longs)
        fun to(longs: LongArray, index: Int) = glm.to(longs, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toLongBuffer(stack: MemoryStack) = glm.toLongBuffer(stack)
        fun to(buf: LongBuffer) = glm.to(buf)
        fun to(buf: LongBuffer, index: Int) = glm.to(buf, index)

        // file: vec2/Vec2us.kt
        fun invoke(x: Ushort, y: Ushort) = glm.invoke(x, y)
        fun invoke(x: Short, y: Short) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(shorts: ShortArray) = glm.to(shorts)
        fun to(shorts: ShortArray, index: Int) = glm.to(shorts, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toShortBuffer(stack: MemoryStack) = glm.toShortBuffer(stack)
        fun to(buf: ShortBuffer) = glm.to(buf)
        fun to(buf: ShortBuffer, index: Int) = glm.to(buf, index)

        // file: vec2/Vec2s.kt
        fun invoke(x: Short, y: Short) = glm.invoke(x, y)
        fun invoke(x: Number, y: Number) = glm.invoke(x, y)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(shorts: ShortArray) = glm.to(shorts)
        fun to(shorts: ShortArray, index: Int) = glm.to(shorts, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toShortBuffer(stack: MemoryStack) = glm.toShortBuffer(stack)
        fun to(buf: ShortBuffer) = glm.to(buf)
        fun to(buf: ShortBuffer, index: Int) = glm.to(buf, index)

        // file: mat4x2/Mat4x2t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: mat4x2/Mat4x2.kt
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)

        // file: mat4x2/Mat4x2d.kt
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec3/Vec3t.kt
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun toByteArray(bigEndian: Boolean = true) = glm.toByteArray(ndian)
        fun to(bytes: ByteArray) = glm.to(bytes)
        fun to(bytes: ByteArray, bigEndian: Boolean) = glm.to(bytes, ndian)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean = true) = glm.to(bytes, index, ndian)
        fun createInstance(x: T, y: T) = glm.createInstance(x, y)
        fun createInstance(x: T, y: T, z: T) = glm.createInstance(x, y, z)

        // file: vec3/Vec3i.kt
        fun invoke(x: Int, y: Int, z: Int) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(ints: IntArray) = glm.to(ints)
        fun to(ints: IntArray, index: Int) = glm.to(ints, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toIntBuffer(stack: MemoryStack) = glm.toIntBuffer(stack)
        fun to(buf: IntBuffer) = glm.to(buf)
        fun to(buf: IntBuffer, index: Int) = glm.to(buf, index)

        // file: vec3/Vec3d.kt
        fun invoke(x: Double, y: Double, z: Double) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)
        fun negate(res: Vec3d = Vec3d()) = glm.negate(res: Vec3d = Vec3d()

        // file: vec3/operators/vec3ui_operators.kt
        fun plus(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.plus(res, a)
        fun plus(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.plus(res, a)
        fun minus(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.minus(res, a)
        fun minus(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.minus(res, a)
        fun minus(res: Vec3ui, aX: Uint, aY: Uint, aZ: Uint, b: Vec3ui) = glm.minus(res, b)
        fun minus(res: Vec3ui, aX: Int, aY: Int, aZ: Int, b: Vec3ui) = glm.minus(res, b)
        fun times(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.times(res, a)
        fun times(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.times(res, a)
        fun div(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.div(res, a)
        fun div(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.div(res, a)
        fun div(res: Vec3ui, aX: Uint, aY: Uint, aZ: Uint, b: Vec3ui) = glm.div(res, b)
        fun div(res: Vec3ui, aX: Int, aY: Int, aZ: Int, b: Vec3ui) = glm.div(res, b)
        fun rem(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.rem(res, a)
        fun rem(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.rem(res, a)
        fun rem(res: Vec3ui, aX: Uint, aY: Uint, aZ: Uint, b: Vec3ui) = glm.rem(res, b)
        fun rem(res: Vec3ui, aX: Int, aY: Int, aZ: Int, b: Vec3ui) = glm.rem(res, b)
        fun and(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.and(res, a)
        fun and(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.and(res, a)
        fun or(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.or(res, a)
        fun or(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.or(res, a)
        fun xor(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.xor(res, a)
        fun xor(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.xor(res, a)
        fun shl(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.shl(res, a)
        fun shl(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.shl(res, a)
        fun shr(res: Vec3ui, a: Vec3ui, bX: Uint, bY: Uint, bZ: Uint) = glm.shr(res, a)
        fun shr(res: Vec3ui, a: Vec3ui, bX: Int, bY: Int, bZ: Int) = glm.shr(res, a)
        fun inv(res: Vec3ui, a: Vec3ui) = glm.inv(res, a)

        // file: vec3/operators/vec3i_operators.kt
        fun plus(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.plus(res, a)
        fun minus(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.minus(res, a)
        fun minus(res: Vec3i, aX: Int, aY: Int, aZ: Int, b: Vec3i) = glm.minus(res, b)
        fun times(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.times(res, a)
        fun div(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.div(res, a)
        fun div(res: Vec3i, aX: Int, aY: Int, aZ: Int, b: Vec3i) = glm.div(res, b)
        fun rem(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.rem(res, a)
        fun rem(res: Vec3i, aX: Int, aY: Int, aZ: Int, b: Vec3i) = glm.rem(res, b)
        fun and(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.and(res, a)
        fun or(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.or(res, a)
        fun xor(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.xor(res, a)
        fun shl(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.shl(res, a)
        fun shr(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.shr(res, a)
        fun ushr(res: Vec3i, a: Vec3i, bX: Int, bY: Int, bZ: Int) = glm.ushr(res, a)
        fun inv(res: Vec3i, a: Vec3i) = glm.inv(res, a)

        // file: vec3/operators/vec3l_operators.kt
        fun plus(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.plus(res, a)
        fun plus(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.plus(res, a)
        fun minus(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.minus(res, a)
        fun minus(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.minus(res, a)
        fun minus(res: Vec3l, aX: Int, aY: Int, aZ: Int, b: Vec3l) = glm.minus(res, b)
        fun minus(res: Vec3l, aX: Long, aY: Long, aZ: Long, b: Vec3l) = glm.minus(res, b)
        fun times(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.times(res, a)
        fun times(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.times(res, a)
        fun div(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.div(res, a)
        fun div(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.div(res, a)
        fun div(res: Vec3l, aX: Int, aY: Int, aZ: Int, b: Vec3l) = glm.div(res, b)
        fun div(res: Vec3l, aX: Long, aY: Long, aZ: Long, b: Vec3l) = glm.div(res, b)
        fun rem(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.rem(res, a)
        fun rem(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.rem(res, a)
        fun rem(res: Vec3l, aX: Int, aY: Int, aZ: Int, b: Vec3l) = glm.rem(res, b)
        fun rem(res: Vec3l, aX: Long, aY: Long, aZ: Long, b: Vec3l) = glm.rem(res, b)
        fun and(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.and(res, a)
        fun and(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.and(res, a)
        fun or(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.or(res, a)
        fun or(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.or(res, a)
        fun xor(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.xor(res, a)
        fun xor(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.xor(res, a)
        fun shl(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.shl(res, a)
        fun shl(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.shl(res, a)
        fun shr(res: Vec3l, a: Vec3l, bX: Long, bY: Long, bZ: Long) = glm.shr(res, a)
        fun shr(res: Vec3l, a: Vec3l, bX: Int, bY: Int, bZ: Int) = glm.shr(res, a)
        fun inv(res: Vec3l, a: Vec3l) = glm.inv(res, a)

        // file: vec3/operators/vec3d_operators.kt
        fun plus(res: Vec3d, a: Vec3d, bX: Double, bY: Double, bZ: Double) = glm.plus(res, a)
        fun minus(res: Vec3d, a: Vec3d, bX: Double, bY: Double, bZ: Double) = glm.minus(res, a)
        fun minus(res: Vec3d, aX: Double, aY: Double, aZ: Double, b: Vec3d) = glm.minus(res, b)
        fun times(res: Vec3d, a: Vec3d, bX: Double, bY: Double, bZ: Double) = glm.times(res, a)
        fun div(res: Vec3d, a: Vec3d, bX: Double, bY: Double, bZ: Double) = glm.div(res, a)
        fun div(res: Vec3d, aX: Double, aY: Double, aZ: Double, b: Vec3d) = glm.div(res, b)
        fun rem(res: Vec3d, a: Vec3d, bX: Double, bY: Double, bZ: Double) = glm.rem(res, a)
        fun rem(res: Vec3d, aX: Double, aY: Double, aZ: Double, b: Vec3d) = glm.rem(res, b)

        // file: vec3/operators/vec3b_operators.kt
        fun plus(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.plus(res, a)
        fun plus(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.plus(res, a)
        fun minus(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.minus(res, a)
        fun minus(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.minus(res, a)
        fun minus(res: Vec3b, aX: Byte, aY: Byte, aZ: Byte, b: Vec3b) = glm.minus(res, b)
        fun minus(res: Vec3b, aX: Int, aY: Int, aZ: Int, b: Vec3b) = glm.minus(res, b)
        fun times(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.times(res, a)
        fun times(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.times(res, a)
        fun div(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.div(res, a)
        fun div(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.div(res, a)
        fun div(res: Vec3b, aX: Byte, aY: Byte, aZ: Byte, b: Vec3b) = glm.div(res, b)
        fun div(res: Vec3b, aX: Int, aY: Int, aZ: Int, b: Vec3b) = glm.div(res, b)
        fun rem(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.rem(res, a)
        fun rem(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.rem(res, a)
        fun rem(res: Vec3b, aX: Byte, aY: Byte, aZ: Byte, b: Vec3b) = glm.rem(res, b)
        fun rem(res: Vec3b, aX: Int, aY: Int, aZ: Int, b: Vec3b) = glm.rem(res, b)
        fun and(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.and(res, a)
        fun and(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.and(res, a)
        fun or(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.or(res, a)
        fun or(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.or(res, a)
        fun xor(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.xor(res, a)
        fun xor(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.xor(res, a)
        fun shl(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.shl(res, a)
        fun shl(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.shl(res, a)
        fun shr(res: Vec3b, a: Vec3b, bX: Byte, bY: Byte, bZ: Byte) = glm.shr(res, a)
        fun shr(res: Vec3b, a: Vec3b, bX: Int, bY: Int, bZ: Int) = glm.shr(res, a)
        fun inv(res: Vec3b, a: Vec3b) = glm.inv(res, a)

        // file: vec3/operators/vec3us_operators.kt
        fun plus(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.plus(res, a)
        fun plus(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.plus(res, a)
        fun plus(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.plus(res, a)
        fun minus(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.minus(res, a)
        fun minus(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.minus(res, a)
        fun minus(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.minus(res, a)
        fun minus(res: Vec3us, aX: Ushort, aY: Ushort, aZ: Ushort, b: Vec3us) = glm.minus(res, b)
        fun minus(res: Vec3us, aX: Short, aY: Short, aZ: Short, b: Vec3us) = glm.minus(res, b)
        fun minus(res: Vec3us, aX: Int, aY: Int, aZ: Int, b: Vec3us) = glm.minus(res, b)
        fun times(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.times(res, a)
        fun times(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.times(res, a)
        fun times(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.times(res, a)
        fun div(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.div(res, a)
        fun div(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.div(res, a)
        fun div(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.div(res, a)
        fun div(res: Vec3us, aX: Ushort, aY: Ushort, aZ: Ushort, b: Vec3us) = glm.div(res, b)
        fun div(res: Vec3us, aX: Short, aY: Short, aZ: Short, b: Vec3us) = glm.div(res, b)
        fun div(res: Vec3us, aX: Int, aY: Int, aZ: Int, b: Vec3us) = glm.div(res, b)
        fun rem(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.rem(res, a)
        fun rem(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.rem(res, a)
        fun rem(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.rem(res, a)
        fun rem(res: Vec3us, aX: Ushort, aY: Ushort, aZ: Ushort, b: Vec3us) = glm.rem(res, b)
        fun rem(res: Vec3us, aX: Short, aY: Short, aZ: Short, b: Vec3us) = glm.rem(res, b)
        fun rem(res: Vec3us, aX: Int, aY: Int, aZ: Int, b: Vec3us) = glm.rem(res, b)
        fun and(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.and(res, a)
        fun and(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.and(res, a)
        fun and(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.and(res, a)
        fun or(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.or(res, a)
        fun or(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.or(res, a)
        fun or(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.or(res, a)
        fun xor(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.xor(res, a)
        fun xor(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.xor(res, a)
        fun xor(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.xor(res, a)
        fun shl(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.shl(res, a)
        fun shl(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.shl(res, a)
        fun shl(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.shl(res, a)
        fun shr(res: Vec3us, a: Vec3us, bX: Ushort, bY: Ushort, bZ: Ushort) = glm.shr(res, a)
        fun shr(res: Vec3us, a: Vec3us, bX: Short, bY: Short, bZ: Short) = glm.shr(res, a)
        fun shr(res: Vec3us, a: Vec3us, bX: Int, bY: Int, bZ: Int) = glm.shr(res, a)
        fun inv(res: Vec3us, a: Vec3us) = glm.inv(res, a)

        // file: vec3/operators/vec3ul_operators.kt
        fun plus(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.plus(res, a)
        fun plus(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.plus(res, a)
        fun plus(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.plus(res, a)
        fun minus(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.minus(res, a)
        fun minus(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.minus(res, a)
        fun minus(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.minus(res, a)
        fun minus(res: Vec3ul, aX: Int, aY: Int, aZ: Int, b: Vec3ul) = glm.minus(res, b)
        fun minus(res: Vec3ul, aX: Ulong, aY: Ulong, aZ: Ulong, b: Vec3ul) = glm.minus(res, b)
        fun minus(res: Vec3ul, aX: Long, aY: Long, aZ: Long, b: Vec3ul) = glm.minus(res, b)
        fun times(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.times(res, a)
        fun times(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.times(res, a)
        fun times(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.times(res, a)
        fun div(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.div(res, a)
        fun div(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.div(res, a)
        fun div(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.div(res, a)
        fun div(res: Vec3ul, aX: Int, aY: Int, aZ: Int, b: Vec3ul) = glm.div(res, b)
        fun div(res: Vec3ul, aX: Ulong, aY: Ulong, aZ: Ulong, b: Vec3ul) = glm.div(res, b)
        fun div(res: Vec3ul, aX: Long, aY: Long, aZ: Long, b: Vec3ul) = glm.div(res, b)
        fun rem(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.rem(res, a)
        fun rem(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.rem(res, a)
        fun rem(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.rem(res, a)
        fun rem(res: Vec3ul, aX: Int, aY: Int, aZ: Int, b: Vec3ul) = glm.rem(res, b)
        fun rem(res: Vec3ul, aX: Ulong, aY: Ulong, aZ: Ulong, b: Vec3ul) = glm.rem(res, b)
        fun rem(res: Vec3ul, aX: Long, aY: Long, aZ: Long, b: Vec3ul) = glm.rem(res, b)
        fun and(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.and(res, a)
        fun and(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.and(res, a)
        fun and(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.and(res, a)
        fun or(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.or(res, a)
        fun or(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.or(res, a)
        fun or(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.or(res, a)
        fun xor(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.xor(res, a)
        fun xor(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.xor(res, a)
        fun xor(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.xor(res, a)
        fun shl(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.shl(res, a)
        fun shl(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.shl(res, a)
        fun shl(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.shl(res, a)
        fun shr(res: Vec3ul, a: Vec3ul, bX: Int, bY: Int, bZ: Int) = glm.shr(res, a)
        fun shr(res: Vec3ul, a: Vec3ul, bX: Long, bY: Long, bZ: Long) = glm.shr(res, a)
        fun shr(res: Vec3ul, a: Vec3ul, bX: Ulong, bY: Ulong, bZ: Ulong) = glm.shr(res, a)
        fun inv(res: Vec3ul, a: Vec3ul) = glm.inv(res, a)

        // file: vec3/operators/vec3s_operators.kt
        fun plus(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.plus(res, a)
        fun plus(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.plus(res, a)
        fun minus(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.minus(res, a)
        fun minus(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.minus(res, a)
        fun minus(res: Vec3s, aX: Short, aY: Short, aZ: Short, b: Vec3s) = glm.minus(res, b)
        fun minus(res: Vec3s, aX: Int, aY: Int, aZ: Int, b: Vec3s) = glm.minus(res, b)
        fun times(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.times(res, a)
        fun times(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.times(res, a)
        fun div(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.div(res, a)
        fun div(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.div(res, a)
        fun div(res: Vec3s, aX: Short, aY: Short, aZ: Short, b: Vec3s) = glm.div(res, b)
        fun div(res: Vec3s, aX: Int, aY: Int, aZ: Int, b: Vec3s) = glm.div(res, b)
        fun rem(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.rem(res, a)
        fun rem(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.rem(res, a)
        fun rem(res: Vec3s, aX: Short, aY: Short, aZ: Short, b: Vec3s) = glm.rem(res, b)
        fun rem(res: Vec3s, aX: Int, aY: Int, aZ: Int, b: Vec3s) = glm.rem(res, b)
        fun and(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.and(res, a)
        fun and(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.and(res, a)
        fun or(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.or(res, a)
        fun or(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.or(res, a)
        fun xor(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.xor(res, a)
        fun xor(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.xor(res, a)
        fun shl(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.shl(res, a)
        fun shl(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.shl(res, a)
        fun shr(res: Vec3s, a: Vec3s, bX: Short, bY: Short, bZ: Short) = glm.shr(res, a)
        fun shr(res: Vec3s, a: Vec3s, bX: Int, bY: Int, bZ: Int) = glm.shr(res, a)
        fun inv(res: Vec3s, a: Vec3s) = glm.inv(res, a)

        // file: vec3/operators/vec3ub_operators.kt
        fun plus(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.plus(res, a)
        fun plus(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.plus(res, a)
        fun plus(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.plus(res, a)
        fun minus(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.minus(res, a)
        fun minus(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.minus(res, a)
        fun minus(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.minus(res, a)
        fun minus(res: Vec3ub, aX: Ubyte, aY: Ubyte, aZ: Ubyte, b: Vec3ub) = glm.minus(res, b)
        fun minus(res: Vec3ub, aX: Byte, aY: Byte, aZ: Byte, b: Vec3ub) = glm.minus(res, b)
        fun minus(res: Vec3ub, aX: Int, aY: Int, aZ: Int, b: Vec3ub) = glm.minus(res, b)
        fun times(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.times(res, a)
        fun times(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.times(res, a)
        fun times(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.times(res, a)
        fun div(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.div(res, a)
        fun div(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.div(res, a)
        fun div(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.div(res, a)
        fun div(res: Vec3ub, aX: Ubyte, aY: Ubyte, aZ: Ubyte, b: Vec3ub) = glm.div(res, b)
        fun div(res: Vec3ub, aX: Byte, aY: Byte, aZ: Byte, b: Vec3ub) = glm.div(res, b)
        fun div(res: Vec3ub, aX: Int, aY: Int, aZ: Int, b: Vec3ub) = glm.div(res, b)
        fun rem(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.rem(res, a)
        fun rem(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.rem(res, a)
        fun rem(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.rem(res, a)
        fun rem(res: Vec3ub, aX: Ubyte, aY: Ubyte, aZ: Ubyte, b: Vec3ub) = glm.rem(res, b)
        fun rem(res: Vec3ub, aX: Byte, aY: Byte, aZ: Byte, b: Vec3ub) = glm.rem(res, b)
        fun rem(res: Vec3ub, aX: Int, aY: Int, aZ: Int, b: Vec3ub) = glm.rem(res, b)
        fun and(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.and(res, a)
        fun and(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.and(res, a)
        fun and(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.and(res, a)
        fun or(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.or(res, a)
        fun or(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.or(res, a)
        fun or(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.or(res, a)
        fun xor(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.xor(res, a)
        fun xor(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.xor(res, a)
        fun xor(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.xor(res, a)
        fun shl(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.shl(res, a)
        fun shl(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.shl(res, a)
        fun shl(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.shl(res, a)
        fun shr(res: Vec3ub, a: Vec3ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte) = glm.shr(res, a)
        fun shr(res: Vec3ub, a: Vec3ub, bX: Byte, bY: Byte, bZ: Byte) = glm.shr(res, a)
        fun shr(res: Vec3ub, a: Vec3ub, bX: Int, bY: Int, bZ: Int) = glm.shr(res, a)
        fun inv(res: Vec3ub, a: Vec3ub) = glm.inv(res, a)

        // file: vec3/operators/vec3_operators.kt
        fun plus(res: Vec3, a: Vec3, bX: Float, bY: Float, bZ: Float) = glm.plus(res, a)
        fun minus(res: Vec3, a: Vec3, bX: Float, bY: Float, bZ: Float) = glm.minus(res, a)
        fun minus(res: Vec3, aX: Float, aY: Float, aZ: Float, b: Vec3) = glm.minus(res, b)
        fun times(res: Vec3, a: Vec3, bX: Float, bY: Float, bZ: Float) = glm.times(res, a)
        fun div(res: Vec3, a: Vec3, bX: Float, bY: Float, bZ: Float) = glm.div(res, a)
        fun div(res: Vec3, aX: Float, aY: Float, aZ: Float, b: Vec3) = glm.div(res, b)
        fun rem(res: Vec3, a: Vec3, bX: Float, bY: Float, bZ: Float) = glm.rem(res, a)
        fun rem(res: Vec3, aX: Float, aY: Float, aZ: Float, b: Vec3) = glm.rem(res, b)

        // file: vec3/Vec3us.kt
        fun invoke(x: Ushort, y: Ushort, z: Ushort) = glm.invoke(x, y, z)
        fun invoke(x: Short, y: Short, z: Short) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(shorts: ShortArray) = glm.to(shorts)
        fun to(shorts: ShortArray, index: Int) = glm.to(shorts, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toShortBuffer(stack: MemoryStack) = glm.toShortBuffer(stack)
        fun to(buf: ShortBuffer) = glm.to(buf)
        fun to(buf: ShortBuffer, index: Int) = glm.to(buf, index)

        // file: vec3/Vec3b.kt
        fun invoke(x: Byte, y: Byte, z: Byte) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec3/Vec3ui.kt
        fun invoke(x: Uint, y: Uint, z: Uint) = glm.invoke(x, y, z)
        fun invoke(x: Int, y: Int, z: Int) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(ints: IntArray) = glm.to(ints)
        fun to(ints: IntArray, index: Int) = glm.to(ints, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toIntBuffer(stack: MemoryStack) = glm.toIntBuffer(stack)
        fun to(buf: IntBuffer) = glm.to(buf)
        fun to(buf: IntBuffer, index: Int) = glm.to(buf, index)

        // file: vec3/Vec3ub.kt
        fun invoke(x: Ubyte, y: Ubyte, z: Ubyte) = glm.invoke(x, y, z)
        fun invoke(x: Byte, y: Byte, z: Byte) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec3/Vec3.kt
        fun invoke(x: Float, y: Float, z: Float) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)
        fun negate(res: Vec3 = Vec3()) = glm.negate(res: Vec3 = Vec3()

        // file: vec3/Vec3s.kt
        fun invoke(x: Short, y: Short, z: Short) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(shorts: ShortArray) = glm.to(shorts)
        fun to(shorts: ShortArray, index: Int) = glm.to(shorts, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toShortBuffer(stack: MemoryStack) = glm.toShortBuffer(stack)
        fun to(shorts: ShortBuffer) = glm.to(shorts)
        fun to(shorts: ShortBuffer, index: Int) = glm.to(shorts, index)

        // file: vec3/Vec3ul.kt
        fun invoke(x: Ulong, y: Ulong, z: Ulong) = glm.invoke(x, y, z)
        fun invoke(x: Long, y: Long, z: Long) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(longs: LongArray) = glm.to(longs)
        fun to(longs: LongArray, index: Int) = glm.to(longs, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toLongBuffer(stack: MemoryStack) = glm.toLongBuffer(stack)
        fun to(buf: LongBuffer) = glm.to(buf)
        fun to(buf: LongBuffer, index: Int) = glm.to(buf, index)

        // file: vec3/Vec3l.kt
        fun invoke(x: Long, y: Long, z: Long) = glm.invoke(x, y, z)
        fun invoke(x: Number, y: Number, z: Number) = glm.invoke(x, y, z)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(longs: LongArray) = glm.to(longs)
        fun to(longs: LongArray, index: Int) = glm.to(longs, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toLongBuffer(stack: MemoryStack) = glm.toLongBuffer(stack)
        fun to(buf: LongBuffer) = glm.to(buf)
        fun to(buf: LongBuffer, index: Int) = glm.to(buf, index)

        // file: vec3/Vec3bool.kt
        fun get(i: Int) = glm.get(i)
        fun put(b: Boolean) = glm.put(b)
        fun put(x: Boolean, y: Boolean, z: Boolean) = glm.put(x, y, z)
        fun put(ba: BooleanArray) = glm.put(ba)
        fun put(ba: Array<Boolean>) = glm.put(ba)
        fun not(res: Vec3bool) = glm.not(res)
        fun and(b: Vec3bool) = glm.and(b)
        fun and(b: Vec3bool, res: Vec3bool) = glm.and(b, res)
        fun or(b: Vec3bool) = glm.or(b)
        fun or(b: Vec3bool, res: Vec3bool) = glm.or(b, res)

        // file: func_matrix.kt
        fun cleanTranslation(res: Mat4, m: Mat4) = glm.cleanTranslation(res, m)
        fun transpose(res: Mat2, m: Mat2) = glm.transpose(res, m)
        fun transpose(res: Mat2d, m: Mat2d) = glm.transpose(res, m)
        fun transpose(res: Mat3, m: Mat3) = glm.transpose(res, m)
        fun transpose(res: Mat3d, m: Mat3d) = glm.transpose(res, m)
        fun transpose(res: Mat4, m: Mat4) = glm.transpose(res, m)
        fun transpose(res: Mat4d, m: Mat4d) = glm.transpose(res, m)
        fun determinant(m: Mat4) = glm.determinant(m)
        fun determinant(m: Mat4d) = glm.determinant(m)
        fun inverse(res: Mat2, m: Mat2) = glm.inverse(res, m)
        fun inverse(res: Mat2d, m: Mat2d) = glm.inverse(res, m)
        fun inverse(res: Mat3, m: Mat3) = glm.inverse(res, m)
        fun inverse(res: Mat3d, m: Mat3d) = glm.inverse(res, m)
        fun inverse(res: Mat4, m: Mat4) = glm.inverse(res, m)
        fun inverse(res: Mat4d, m: Mat4d) = glm.inverse(res, m)
        fun matrixCompMult(res: Mat2, a: Mat2, b: Mat2) = glm.matrixCompMult(res, a, b)
        fun matrixCompMult(res: Mat3, a: Mat3, b: Mat3) = glm.matrixCompMult(res, a, b)
        fun matrixCompMult(res: Mat4, a: Mat4, b: Mat4) = glm.matrixCompMult(res, a, b)
        fun outerProduct(res: Mat2, c: Vec2, r: Vec2) = glm.outerProduct(res, c, r)
        fun outerProduct(res: Mat3, c: Vec3, r: Vec3) = glm.outerProduct(res, c, r)
        fun outerProduct(res: Mat4, c: Vec4, r: Vec4) = glm.outerProduct(res, c, r)

        // file: round.kt
        fun ceilMultiple(source: Vec3i, multiple: Vec3i, res: Vec3i) = glm.ceilMultiple(source, multiple, res)

        // file: gauss.kt
        fun gauss(coord: Vec2, expectedValue: Vec2, standardDeviation: Vec2, res: Vec2 = Vec2()) = glm.gauss(coord: Vec2, expectedValue: Vec2, standardDeviation: Vec2, res: Vec2 = Vec2()
        fun gauss(coord: Vec2d, expectedValue: Vec2d, standardDeviation: Vec2d, res: Vec2d = Vec2d()) = glm.gauss(coord: Vec2d, expectedValue: Vec2d, standardDeviation: Vec2d, res: Vec2d = Vec2d()

        // file: vec4/Vec4t.kt
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun toByteArray(bigEndian: Boolean = true) = glm.toByteArray(ndian)
        fun to(bytes: ByteArray) = glm.to(bytes)
        fun to(bytes: ByteArray, bigEndian: Boolean) = glm.to(bytes, ndian)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean = true) = glm.to(bytes, index, ndian)
        fun createInstance(x: T, y: T) = glm.createInstance(x, y)
        fun createInstance(x: T, y: T, z: T) = glm.createInstance(x, y, z)
        fun createInstance(x: T, y: T, z: T, w: T) = glm.createInstance(x, y, z, w)

        // file: vec4/Vec4s.kt
        fun invoke(x: Short, y: Short, z: Short, w: Short) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(shorts: ShortArray) = glm.to(shorts)
        fun to(shorts: ShortArray, index: Int) = glm.to(shorts, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toShortBuffer(stack: MemoryStack) = glm.toShortBuffer(stack)
        fun to(buf: ShortBuffer) = glm.to(buf)
        fun to(buf: ShortBuffer, index: Int) = glm.to(buf, index)

        // file: vec4/Vec4l.kt
        fun invoke(x: Long, y: Long, z: Long, w: Long) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(longs: LongArray) = glm.to(longs)
        fun to(longs: LongArray, index: Int) = glm.to(longs, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toLongBuffer(stack: MemoryStack) = glm.toLongBuffer(stack)
        fun to(buf: LongBuffer) = glm.to(buf)
        fun to(buf: LongBuffer, index: Int) = glm.to(buf, index)

        // file: vec4/Vec4ul.kt
        fun invoke(x: Ulong, y: Ulong, z: Ulong, w: Ulong) = glm.invoke(x, y, z, w)
        fun invoke(x: Long, y: Long, z: Long, w: Long) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(longs: LongArray) = glm.to(longs)
        fun to(longs: LongArray, index: Int) = glm.to(longs, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toLongBuffer(stack: MemoryStack) = glm.toLongBuffer(stack)
        fun to(longs: LongBuffer) = glm.to(longs)
        fun to(longs: LongBuffer, index: Int) = glm.to(longs, index)

        // file: vec4/Vec4b.kt
        fun invoke(x: Byte, y: Byte, z: Byte, w: Byte) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec4/operators/vec4b_operators.kt
        fun plus(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.plus(res, a)
        fun plus(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.plus(res, a)
        fun minus(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.minus(res, a)
        fun minus(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.minus(res, a)
        fun minus(res: Vec4b, aX: Byte, aY: Byte, aZ: Byte, aW: Byte, b: Vec4b) = glm.minus(res, b)
        fun minus(res: Vec4b, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4b) = glm.minus(res, b)
        fun times(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.times(res, a)
        fun times(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.times(res, a)
        fun div(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.div(res, a)
        fun div(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.div(res, a)
        fun div(res: Vec4b, aX: Byte, aY: Byte, aZ: Byte, aW: Byte, b: Vec4b) = glm.div(res, b)
        fun div(res: Vec4b, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4b) = glm.div(res, b)
        fun rem(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.rem(res, a)
        fun rem(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.rem(res, a)
        fun rem(res: Vec4b, aX: Byte, aY: Byte, aZ: Byte, aW: Byte, b: Vec4b) = glm.rem(res, b)
        fun rem(res: Vec4b, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4b) = glm.rem(res, b)
        fun and(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.and(res, a)
        fun and(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.and(res, a)
        fun or(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.or(res, a)
        fun or(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.or(res, a)
        fun xor(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.xor(res, a)
        fun xor(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.xor(res, a)
        fun shl(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.shl(res, a)
        fun shl(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shl(res, a)
        fun shr(res: Vec4b, a: Vec4b, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.shr(res, a)
        fun shr(res: Vec4b, a: Vec4b, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shr(res, a)
        fun inv(res: Vec4b, a: Vec4b) = glm.inv(res, a)

        // file: vec4/operators/vec4us_operators.kt
        fun plus(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.plus(res, a)
        fun plus(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.plus(res, a)
        fun plus(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.plus(res, a)
        fun minus(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.minus(res, a)
        fun minus(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.minus(res, a)
        fun minus(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.minus(res, a)
        fun minus(res: Vec4us, aX: Ushort, aY: Ushort, aZ: Ushort, aW: Ushort, b: Vec4us) = glm.minus(res, b)
        fun minus(res: Vec4us, aX: Short, aY: Short, aZ: Short, aW: Short, b: Vec4us) = glm.minus(res, b)
        fun minus(res: Vec4us, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4us) = glm.minus(res, b)
        fun times(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.times(res, a)
        fun times(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.times(res, a)
        fun times(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.times(res, a)
        fun div(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.div(res, a)
        fun div(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.div(res, a)
        fun div(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.div(res, a)
        fun div(res: Vec4us, aX: Ushort, aY: Ushort, aZ: Ushort, aW: Ushort, b: Vec4us) = glm.div(res, b)
        fun div(res: Vec4us, aX: Short, aY: Short, aZ: Short, aW: Short, b: Vec4us) = glm.div(res, b)
        fun div(res: Vec4us, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4us) = glm.div(res, b)
        fun rem(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.rem(res, a)
        fun rem(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.rem(res, a)
        fun rem(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.rem(res, a)
        fun rem(res: Vec4us, aX: Ushort, aY: Ushort, aZ: Ushort, aW: Ushort, b: Vec4us) = glm.rem(res, b)
        fun rem(res: Vec4us, aX: Short, aY: Short, aZ: Short, aW: Short, b: Vec4us) = glm.rem(res, b)
        fun rem(res: Vec4us, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4us) = glm.rem(res, b)
        fun and(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.and(res, a)
        fun and(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.and(res, a)
        fun and(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.and(res, a)
        fun or(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.or(res, a)
        fun or(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.or(res, a)
        fun or(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.or(res, a)
        fun xor(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.xor(res, a)
        fun xor(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.xor(res, a)
        fun xor(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.xor(res, a)
        fun shl(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.shl(res, a)
        fun shl(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.shl(res, a)
        fun shl(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shl(res, a)
        fun shr(res: Vec4us, a: Vec4us, bX: Ushort, bY: Ushort, bZ: Ushort, bW: Ushort) = glm.shr(res, a)
        fun shr(res: Vec4us, a: Vec4us, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.shr(res, a)
        fun shr(res: Vec4us, a: Vec4us, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shr(res, a)
        fun inv(res: Vec4us, a: Vec4us) = glm.inv(res, a)

        // file: vec4/operators/vec4ui_operators.kt
        fun plus(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.plus(res, a)
        fun plus(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.plus(res, a)
        fun minus(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.minus(res, a)
        fun minus(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.minus(res, a)
        fun minus(res: Vec4ui, aX: Uint, aY: Uint, aZ: Uint, aW: Uint, b: Vec4ui) = glm.minus(res, b)
        fun minus(res: Vec4ui, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ui) = glm.minus(res, b)
        fun times(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.times(res, a)
        fun times(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.times(res, a)
        fun div(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.div(res, a)
        fun div(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.div(res, a)
        fun div(res: Vec4ui, aX: Uint, aY: Uint, aZ: Uint, aW: Uint, b: Vec4ui) = glm.div(res, b)
        fun div(res: Vec4ui, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ui) = glm.div(res, b)
        fun rem(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.rem(res, a)
        fun rem(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.rem(res, a)
        fun rem(res: Vec4ui, aX: Uint, aY: Uint, aZ: Uint, aW: Uint, b: Vec4ui) = glm.rem(res, b)
        fun rem(res: Vec4ui, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ui) = glm.rem(res, b)
        fun and(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.and(res, a)
        fun and(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.and(res, a)
        fun or(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.or(res, a)
        fun or(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.or(res, a)
        fun xor(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.xor(res, a)
        fun xor(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.xor(res, a)
        fun shl(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.shl(res, a)
        fun shl(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shl(res, a)
        fun shr(res: Vec4ui, a: Vec4ui, bX: Uint, bY: Uint, bZ: Uint, bW: Uint) = glm.shr(res, a)
        fun shr(res: Vec4ui, a: Vec4ui, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shr(res, a)
        fun inv(res: Vec4ui, a: Vec4ui) = glm.inv(res, a)

        // file: vec4/operators/vec4s_operators.kt
        fun plus(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.plus(res, a)
        fun plus(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.plus(res, a)
        fun minus(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.minus(res, a)
        fun minus(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.minus(res, a)
        fun minus(res: Vec4s, aX: Short, aY: Short, aZ: Short, aW: Short, b: Vec4s) = glm.minus(res, b)
        fun minus(res: Vec4s, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4s) = glm.minus(res, b)
        fun times(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.times(res, a)
        fun times(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.times(res, a)
        fun div(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.div(res, a)
        fun div(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.div(res, a)
        fun div(res: Vec4s, aX: Short, aY: Short, aZ: Short, aW: Short, b: Vec4s) = glm.div(res, b)
        fun div(res: Vec4s, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4s) = glm.div(res, b)
        fun rem(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.rem(res, a)
        fun rem(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.rem(res, a)
        fun rem(res: Vec4s, aX: Short, aY: Short, aZ: Short, aW: Short, b: Vec4s) = glm.rem(res, b)
        fun rem(res: Vec4s, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4s) = glm.rem(res, b)
        fun and(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.and(res, a)
        fun and(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.and(res, a)
        fun or(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.or(res, a)
        fun or(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.or(res, a)
        fun xor(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.xor(res, a)
        fun xor(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.xor(res, a)
        fun shl(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.shl(res, a)
        fun shl(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shl(res, a)
        fun shr(res: Vec4s, a: Vec4s, bX: Short, bY: Short, bZ: Short, bW: Short) = glm.shr(res, a)
        fun shr(res: Vec4s, a: Vec4s, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shr(res, a)
        fun inv(res: Vec4s, a: Vec4s) = glm.inv(res, a)

        // file: vec4/operators/vec4ul_operators.kt
        fun plus(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.plus(res, a)
        fun plus(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.plus(res, a)
        fun plus(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.plus(res, a)
        fun minus(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.minus(res, a)
        fun minus(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.minus(res, a)
        fun minus(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.minus(res, a)
        fun minus(res: Vec4ul, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ul) = glm.minus(res, b)
        fun minus(res: Vec4ul, aX: Ulong, aY: Ulong, aZ: Ulong, aW: Ulong, b: Vec4ul) = glm.minus(res, b)
        fun minus(res: Vec4ul, aX: Long, aY: Long, aZ: Long, aW: Long, b: Vec4ul) = glm.minus(res, b)
        fun times(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.times(res, a)
        fun times(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.times(res, a)
        fun times(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.times(res, a)
        fun div(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.div(res, a)
        fun div(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.div(res, a)
        fun div(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.div(res, a)
        fun div(res: Vec4ul, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ul) = glm.div(res, b)
        fun div(res: Vec4ul, aX: Ulong, aY: Ulong, aZ: Ulong, aW: Ulong, b: Vec4ul) = glm.div(res, b)
        fun div(res: Vec4ul, aX: Long, aY: Long, aZ: Long, aW: Long, b: Vec4ul) = glm.div(res, b)
        fun rem(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.rem(res, a)
        fun rem(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.rem(res, a)
        fun rem(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.rem(res, a)
        fun rem(res: Vec4ul, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ul) = glm.rem(res, b)
        fun rem(res: Vec4ul, aX: Ulong, aY: Ulong, aZ: Ulong, aW: Ulong, b: Vec4ul) = glm.rem(res, b)
        fun rem(res: Vec4ul, aX: Long, aY: Long, aZ: Long, aW: Long, b: Vec4ul) = glm.rem(res, b)
        fun and(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.and(res, a)
        fun and(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.and(res, a)
        fun and(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.and(res, a)
        fun or(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.or(res, a)
        fun or(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.or(res, a)
        fun or(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.or(res, a)
        fun xor(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.xor(res, a)
        fun xor(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.xor(res, a)
        fun xor(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.xor(res, a)
        fun shl(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shl(res, a)
        fun shl(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.shl(res, a)
        fun shl(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.shl(res, a)
        fun shr(res: Vec4ul, a: Vec4ul, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shr(res, a)
        fun shr(res: Vec4ul, a: Vec4ul, bX: Ulong, bY: Ulong, bZ: Ulong, bW: Ulong) = glm.shr(res, a)
        fun shr(res: Vec4ul, a: Vec4ul, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.shr(res, a)
        fun inv(res: Vec4ul, a: Vec4ul) = glm.inv(res, a)

        // file: vec4/operators/vec4bool_operators.kt
        fun and(res: Vec4bool, a: Vec4bool, bX: Boolean, bY: Boolean, bZ: Boolean, bW: Boolean) = glm.and(res, a)
        fun or(res: Vec4bool, a: Vec4bool, bX: Boolean, bY: Boolean, bZ: Boolean, bW: Boolean) = glm.or(res, a)
        fun xor(res: Vec4bool, a: Vec4bool, bX: Boolean, bY: Boolean, bZ: Boolean, bW: Boolean) = glm.xor(res, a)

        // file: vec4/operators/vec4i_operators.kt
        fun plus(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.plus(res, a)
        fun minus(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.minus(res, a)
        fun minus(res: Vec4i, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4i) = glm.minus(res, b)
        fun times(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.times(res, a)
        fun div(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.div(res, a)
        fun div(res: Vec4i, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4i) = glm.div(res, b)
        fun rem(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.rem(res, a)
        fun rem(res: Vec4i, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4i) = glm.rem(res, b)
        fun and(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.and(res, a)
        fun or(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.or(res, a)
        fun xor(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.xor(res, a)
        fun shl(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shl(res, a)
        fun shr(res: Vec4i, a: Vec4i, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shr(res, a)
        fun inv(res: Vec4i, a: Vec4i) = glm.inv(res, a)

        // file: vec4/operators/vec4ub_operators.kt
        fun plus(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.plus(res, a)
        fun plus(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.plus(res, a)
        fun plus(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.plus(res, a)
        fun minus(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.minus(res, a)
        fun minus(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.minus(res, a)
        fun minus(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.minus(res, a)
        fun minus(res: Vec4ub, aX: Ubyte, aY: Ubyte, aZ: Ubyte, aW: Ubyte, b: Vec4ub) = glm.minus(res, b)
        fun minus(res: Vec4ub, aX: Byte, aY: Byte, aZ: Byte, aW: Byte, b: Vec4ub) = glm.minus(res, b)
        fun minus(res: Vec4ub, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ub) = glm.minus(res, b)
        fun times(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.times(res, a)
        fun times(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.times(res, a)
        fun times(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.times(res, a)
        fun div(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.div(res, a)
        fun div(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.div(res, a)
        fun div(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.div(res, a)
        fun div(res: Vec4ub, aX: Ubyte, aY: Ubyte, aZ: Ubyte, aW: Ubyte, b: Vec4ub) = glm.div(res, b)
        fun div(res: Vec4ub, aX: Byte, aY: Byte, aZ: Byte, aW: Byte, b: Vec4ub) = glm.div(res, b)
        fun div(res: Vec4ub, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ub) = glm.div(res, b)
        fun rem(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.rem(res, a)
        fun rem(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.rem(res, a)
        fun rem(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.rem(res, a)
        fun rem(res: Vec4ub, aX: Ubyte, aY: Ubyte, aZ: Ubyte, aW: Ubyte, b: Vec4ub) = glm.rem(res, b)
        fun rem(res: Vec4ub, aX: Byte, aY: Byte, aZ: Byte, aW: Byte, b: Vec4ub) = glm.rem(res, b)
        fun rem(res: Vec4ub, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4ub) = glm.rem(res, b)
        fun and(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.and(res, a)
        fun and(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.and(res, a)
        fun and(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.and(res, a)
        fun or(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.or(res, a)
        fun or(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.or(res, a)
        fun or(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.or(res, a)
        fun xor(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.xor(res, a)
        fun xor(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.xor(res, a)
        fun xor(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.xor(res, a)
        fun shl(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.shl(res, a)
        fun shl(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.shl(res, a)
        fun shl(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shl(res, a)
        fun shr(res: Vec4ub, a: Vec4ub, bX: Ubyte, bY: Ubyte, bZ: Ubyte, bW: Ubyte) = glm.shr(res, a)
        fun shr(res: Vec4ub, a: Vec4ub, bX: Byte, bY: Byte, bZ: Byte, bW: Byte) = glm.shr(res, a)
        fun shr(res: Vec4ub, a: Vec4ub, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shr(res, a)
        fun inv(res: Vec4ub, a: Vec4ub) = glm.inv(res, a)

        // file: vec4/operators/vec4d_operators.kt
        fun plus(res: Vec4d, a: Vec4d, bX: Double, bY: Double, bZ: Double, bW: Double) = glm.plus(res, a)
        fun minus(res: Vec4d, a: Vec4d, bX: Double, bY: Double, bZ: Double, bW: Double) = glm.minus(res, a)
        fun minus(res: Vec4d, aX: Double, aY: Double, aZ: Double, aW: Double, b: Vec4d) = glm.minus(res, b)
        fun times(res: Vec4d, a: Vec4d, bX: Double, bY: Double, bZ: Double, bW: Double) = glm.times(res, a)
        fun div(res: Vec4d, a: Vec4d, bX: Double, bY: Double, bZ: Double, bW: Double) = glm.div(res, a)
        fun div(res: Vec4d, aX: Double, aY: Double, aZ: Double, aW: Double, b: Vec4d) = glm.div(res, b)
        fun rem(res: Vec4d, a: Vec4d, bX: Double, bY: Double, bZ: Double, bW: Double) = glm.rem(res, a)
        fun rem(res: Vec4d, aX: Double, aY: Double, aZ: Double, aW: Double, b: Vec4d) = glm.rem(res, b)

        // file: vec4/operators/vec4l_operators.kt
        fun plus(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.plus(res, a)
        fun plus(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.plus(res, a)
        fun minus(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.minus(res, a)
        fun minus(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.minus(res, a)
        fun minus(res: Vec4l, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4l) = glm.minus(res, b)
        fun minus(res: Vec4l, aX: Long, aY: Long, aZ: Long, aW: Long, b: Vec4l) = glm.minus(res, b)
        fun times(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.times(res, a)
        fun times(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.times(res, a)
        fun div(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.div(res, a)
        fun div(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.div(res, a)
        fun div(res: Vec4l, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4l) = glm.div(res, b)
        fun div(res: Vec4l, aX: Long, aY: Long, aZ: Long, aW: Long, b: Vec4l) = glm.div(res, b)
        fun rem(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.rem(res, a)
        fun rem(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.rem(res, a)
        fun rem(res: Vec4l, aX: Int, aY: Int, aZ: Int, aW: Int, b: Vec4l) = glm.rem(res, b)
        fun rem(res: Vec4l, aX: Long, aY: Long, aZ: Long, aW: Long, b: Vec4l) = glm.rem(res, b)
        fun and(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.and(res, a)
        fun and(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.and(res, a)
        fun or(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.or(res, a)
        fun or(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.or(res, a)
        fun xor(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.xor(res, a)
        fun xor(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.xor(res, a)
        fun shl(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shl(res, a)
        fun shl(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.shl(res, a)
        fun shr(res: Vec4l, a: Vec4l, bX: Int, bY: Int, bZ: Int, bW: Int) = glm.shr(res, a)
        fun shr(res: Vec4l, a: Vec4l, bX: Long, bY: Long, bZ: Long, bW: Long) = glm.shr(res, a)
        fun inv(res: Vec4l, a: Vec4l) = glm.inv(res, a)

        // file: vec4/operators/vec4_operators.kt
        fun plus(res: Vec4, a: Vec4, bX: Float, bY: Float, bZ: Float, bW: Float) = glm.plus(res, a)
        fun minus(res: Vec4, a: Vec4, bX: Float, bY: Float, bZ: Float, bW: Float) = glm.minus(res, a)
        fun minus(res: Vec4, aX: Float, aY: Float, aZ: Float, aW: Float, b: Vec4) = glm.minus(res, b)
        fun times(res: Vec4, a: Vec4, bX: Float, bY: Float, bZ: Float, bW: Float) = glm.times(res, a)
        fun div(res: Vec4, a: Vec4, bX: Float, bY: Float, bZ: Float, bW: Float) = glm.div(res, a)
        fun div(res: Vec4, aX: Float, aY: Float, aZ: Float, aW: Float, b: Vec4) = glm.div(res, b)
        fun rem(res: Vec4, a: Vec4, bX: Float, bY: Float, bZ: Float, bW: Float) = glm.rem(res, a)
        fun rem(res: Vec4, aX: Float, aY: Float, aZ: Float, aW: Float, b: Vec4) = glm.rem(res, b)

        // file: vec4/Vec4ub.kt
        fun invoke(x: Ubyte, y: Ubyte, z: Ubyte, w: Ubyte) = glm.invoke(x, y, z, w)
        fun invoke(x: Byte, y: Byte, z: Byte, w: Byte) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec4/Vec4i.kt
        fun invoke(x: Int, y: Int, z: Int, w: Int) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(ints: IntArray) = glm.to(ints)
        fun to(ints: IntArray, index: Int) = glm.to(ints, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toIntBuffer(stack: MemoryStack) = glm.toIntBuffer(stack)
        fun to(buf: IntBuffer) = glm.to(buf)
        fun to(buf: IntBuffer, index: Int) = glm.to(buf, index)

        // file: vec4/Vec4.kt
        fun invoke(x: Float, y: Float, z: Float, w: Float) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)
        fun negate(res: Vec4 = Vec4()) = glm.negate(res: Vec4 = Vec4()
        fun toColor(normalized: Boolean = true) = glm.toColor(normalized)

        // file: vec4/Vec4bool.kt
        fun get(i: Int) = glm.get(i)
        fun put(b: Boolean) = glm.put(b)
        fun put(x: Boolean, y: Boolean, z: Boolean) = glm.put(x, y, z)
        fun put(ba: BooleanArray) = glm.put(ba)
        fun put(ba: Array<Boolean>) = glm.put(ba)
        fun not(res: Vec4bool) = glm.not(res)

        // file: vec4/Vec4ui.kt
        fun invoke(x: Uint, y: Uint, z: Uint, w: Uint) = glm.invoke(x, y, z, w)
        fun invoke(x: Int, y: Int, z: Int, w: Int) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(ints: IntArray) = glm.to(ints)
        fun to(ints: IntArray, index: Int) = glm.to(ints, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toIntBuffer(stack: MemoryStack) = glm.toIntBuffer(stack)
        fun to(buf: IntBuffer) = glm.to(buf)
        fun to(buf: IntBuffer, index: Int) = glm.to(buf, index)

        // file: vec4/Vec4d.kt
        fun invoke(x: Double, y: Double, z: Double, w: Double) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)

        // file: vec4/Vec4us.kt
        fun invoke(x: Ushort, y: Ushort, z: Ushort, w: Ushort) = glm.invoke(x, y, z, w)
        fun invoke(x: Short, y: Short, z: Short, w: Short) = glm.invoke(x, y, z, w)
        fun invoke(x: Number, y: Number, z: Number, w: Number) = glm.invoke(x, y, z, w)
        fun to(bytes: ByteArray, index: Int) = glm.to(bytes, index)
        fun to(bytes: ByteArray, index: Int, bigEndian: Boolean) = glm.to(bytes, index, ndian)
        fun to(shorts: ShortArray) = glm.to(shorts)
        fun to(shorts: ShortArray, index: Int) = glm.to(shorts, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun toShortBuffer(stack: MemoryStack) = glm.toShortBuffer(stack)
        fun to(shorts: ShortBuffer) = glm.to(shorts)
        fun to(shorts: ShortBuffer, index: Int) = glm.to(shorts, index)

        // file: packing_detail.kt
        fun float2half(f: Int) = glm.float2half(f)
        fun float2packed11(f: Int) = glm.float2packed11(f)
        fun packed11ToFloat(p: Int) = glm.packed11ToFloat(p)
        fun float2packed10(f: Int) = glm.float2packed10(f)
        fun packed10ToFloat(p: Int) = glm.packed10ToFloat(p)
        fun floatTo11bit(x: Float) = glm.floatTo11bit(x)
        fun packed11bitToFloat(x: Int) = glm.packed11bitToFloat(x)
        fun floatTo10bit(x: Float) = glm.floatTo10bit(x)
        fun packed10bitToFloat(x: Int) = glm.packed10bitToFloat(x)
        fun packUnorm2x8(v: Vec2) = glm.packUnorm2x8(v)
        fun unpackUnorm2x8(p: Short, res: Vec2 = Vec2()) = glm.unpackUnorm2x8(p: Short, res: Vec2 = Vec2()
        fun packSnorm2x8(v: Vec2) = glm.packSnorm2x8(v)
        fun unpackSnorm2x8(p: Short, res: Vec2 = Vec2()) = glm.unpackSnorm2x8(p: Short, res: Vec2 = Vec2()
        fun packUnorm4x16(v: Vec4) = glm.packUnorm4x16(v)
        fun unpackUnorm4x16(p: Long, res: Vec4 = Vec4()) = glm.unpackUnorm4x16(p: Long, res: Vec4 = Vec4()
        fun packSnorm4x16(v: Vec4) = glm.packSnorm4x16(v)
        fun unpackSnorm4x16(p: Long, res: Vec4 = Vec4()) = glm.unpackSnorm4x16(p: Long, res: Vec4 = Vec4()
        fun packHalf4x16(v: Vec4) = glm.packHalf4x16(v)
        fun unpackHalf4x16(v: Long, res: Vec4 = Vec4()) = glm.unpackHalf4x16(v: Long, res: Vec4 = Vec4()
        fun packI3x10_1x2(v: Vec4i) = glm.packI3x10_1x2(v)
        fun unpackI3x10_1x2(v: Int, res: Vec4i = Vec4i()) = glm.unpackI3x10_1x2(v: Int, res: Vec4i = Vec4i()
        fun packU3x10_1x2(v: Vec4i) = glm.packU3x10_1x2(v)
        fun unpackU3x10_1x2(v: Int, res: Vec4i = Vec4i()) = glm.unpackU3x10_1x2(v: Int, res: Vec4i = Vec4i()
        fun packSnorm3x10_1x2(v: Vec4) = glm.packSnorm3x10_1x2(v)
        fun unpackSnorm3x10_1x2(v: Int, res: Vec4 = Vec4()) = glm.unpackSnorm3x10_1x2(v: Int, res: Vec4 = Vec4()
        fun packUnorm3x10_1x2(v: Vec4) = glm.packUnorm3x10_1x2(v)
        fun unpackUnorm3x10_1x2(v: Int, res: Vec4 = Vec4()) = glm.unpackUnorm3x10_1x2(v: Int, res: Vec4 = Vec4()
        fun unpackF2x11_1x10(v: Int, res: Vec3 = Vec3()) = glm.unpackF2x11_1x10(v: Int, res: Vec3 = Vec3()
        fun packF3x9_E1x5(v: Vec3) = glm.packF3x9_E1x5(v)
        fun unpackF3x9_E1x5(v: Int, res: Vec3 = Vec3()) = glm.unpackF3x9_E1x5(v: Int, res: Vec3 = Vec3()
        fun packRGBM(rgb: Vec3, res: Vec4 = Vec4()) = glm.packRGBM(rgb: Vec3, res: Vec4 = Vec4()
        fun unpackRGBM(rgbm: Vec4, res: Vec3 = Vec3()) = glm.unpackRGBM(rgbm: Vec4, res: Vec3 = Vec3()
        fun packUnorm2x4(v: Vec2) = glm.packUnorm2x4(v)
        fun unpackUnorm2x4(v: Byte, res: Vec2 = Vec2()) = glm.unpackUnorm2x4(v: Byte, res: Vec2 = Vec2()
        fun packUnorm4x4(v: Vec4) = glm.packUnorm4x4(v)
        fun unpackUnorm4x4(v: Short, res: Vec4 = Vec4()) = glm.unpackUnorm4x4(v: Short, res: Vec4 = Vec4()
        fun packUnorm1x5_1x6_1x5(v: Vec3) = glm.packUnorm1x5_1x6_1x5(v)
        fun unpackUnorm1x5_1x6_1x5(v: Short, res: Vec3 = Vec3()) = glm.unpackUnorm1x5_1x6_1x5(v: Short, res: Vec3 = Vec3()
        fun packUnorm3x5_1x1(v: Vec4) = glm.packUnorm3x5_1x1(v)
        fun unpackUnorm3x5_1x1(v: Short, res: Vec4 = Vec4()) = glm.unpackUnorm3x5_1x1(v: Short, res: Vec4 = Vec4()
        fun packUnorm2x3_1x2(v: Vec3) = glm.packUnorm2x3_1x2(v)
        fun unpackUnorm2x3_1x2(v: Byte, res: Vec3 = Vec3()) = glm.unpackUnorm2x3_1x2(v: Byte, res: Vec3 = Vec3()
        fun packInt2x8(v: Vec2b) = glm.packInt2x8(v)
        fun unpackInt2x8(p: Short, res: Vec2b = Vec2b()) = glm.unpackInt2x8(p: Short, res: Vec2b = Vec2b()

        // file: mat4x4/operators/mat4_operators.kt
        fun plus(res: Mat4, a: Mat4, b: Float) = glm.plus(res, a, b)
        fun minus(res: Mat4, a: Mat4, b: Float) = glm.minus(res, a, b)
        fun minus(res: Mat4, a: Float, b: Mat4) = glm.minus(res, a, b)
        fun times(res: Mat4, a: Mat4, b: Float) = glm.times(res, a, b)
        fun div(res: Mat4, a: Mat4, b: Float) = glm.div(res, a, b)
        fun div(res: Mat4, a: Float, b: Mat4) = glm.div(res, a, b)
        fun times(res: Vec4, a: Mat4, b0: Float, b1: Float, b2: Float, b3: Float) = glm.times(res, a)
        fun times(res: Vec4, a0: Float, a1: Float, a2: Float, a3: Float, b: Mat4) = glm.times(res, b)
        fun times(res: Mat4, a: Mat4, b: Mat4) = glm.times(res, a, b)
        fun div(res: Vec4, a: Mat4, b0: Float, b1: Float, b2: Float, b3: Float) = glm.div(res, a)
        fun div(res: Vec4, a0: Float, a1: Float, a2: Float, a3: Float, b: Mat4) = glm.div(res, b)

        // file: mat4x4/operators/mat4d_operators.kt
        fun plus(res: Mat4d, a: Mat4d, b: Double) = glm.plus(res, a, b)
        fun minus(res: Mat4d, a: Mat4d, b: Double) = glm.minus(res, a, b)
        fun minus(res: Mat4d, a: Double, b: Mat4d) = glm.minus(res, a, b)
        fun times(res: Mat4d, a: Mat4d, b: Double) = glm.times(res, a, b)
        fun div(res: Mat4d, a: Mat4d, b: Double) = glm.div(res, a, b)
        fun div(res: Mat4d, a: Double, b: Mat4d) = glm.div(res, a, b)
        fun times(res: Vec4d, a: Mat4d, b0: Double, b1: Double, b2: Double, b3: Double) = glm.times(res, a)
        fun times(res: Vec4d, a0: Double, a1: Double, a2: Double, a3: Double, b: Mat4d) = glm.times(res, b)
        fun div(res: Vec4d, a: Mat4d, b0: Double, b1: Double, b2: Double, b3: Double) = glm.div(res, a)
        fun div(res: Vec4d, a0: Double, a1: Double, a2: Double, a3: Double, b: Mat4d) = glm.div(res, b)

        // file: mat4x4/Mat4.kt
        fun to(res: Mat3) = glm.to(res)
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)
        fun inc(res: Mat4 = Mat4()) = glm.inc(res: Mat4 = Mat4()
        fun dec(res: Mat4 = Mat4()) = glm.dec(res: Mat4 = Mat4()
        fun fromPointer(ptr: Ptr, transpose: Boolean = false) = glm.fromPointer(ptr, transpose)

        // file: mat4x4/Mat4d.kt
        fun to(res: Mat3d) = glm.to(res)
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)
        fun inc(res: Mat4d = Mat4d()) = glm.inc(res: Mat4d = Mat4d()
        fun dec(res: Mat4d = Mat4d()) = glm.dec(res: Mat4d = Mat4d()
        fun fromPointer(ptr: Ptr, transpose: Boolean = false) = glm.fromPointer(ptr, transpose)

        // file: mat4x4/Mat4x4t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: random.kt
        fun linearRand(min: Float, max: Float) = glm.linearRand(min, max)
        fun linearRand(min: Double, max: Double) = glm.linearRand(min, max)
        fun linearRand(min: Int, max: Int) = glm.linearRand(min, max)
        fun linearRand(min: Long, max: Long) = glm.linearRand(min, max)
        fun linearRand(min: Vec2, max: Vec2, res: Vec2 = Vec2()) = glm.linearRand(min: Vec2, max: Vec2, res: Vec2 = Vec2()
        fun linearRand(min: Vec2d, max: Vec2d, res: Vec2d = Vec2d()) = glm.linearRand(min: Vec2d, max: Vec2d, res: Vec2d = Vec2d()
        fun linearRand(min: Vec2b, max: Vec2b, res: Vec2b = Vec2b()) = glm.linearRand(min: Vec2b, max: Vec2b, res: Vec2b = Vec2b()
        fun linearRand(min: Vec3, max: Vec3, res: Vec3 = Vec3()) = glm.linearRand(min: Vec3, max: Vec3, res: Vec3 = Vec3()
        fun linearRand(min: Vec3d, max: Vec3d, res: Vec3d = Vec3d()) = glm.linearRand(min: Vec3d, max: Vec3d, res: Vec3d = Vec3d()
        fun linearRand(min: Vec4, max: Vec4, res: Vec4 = Vec4()) = glm.linearRand(min: Vec4, max: Vec4, res: Vec4 = Vec4()
        fun linearRand(min: Vec4d, max: Vec4d, res: Vec4d = Vec4d()) = glm.linearRand(min: Vec4d, max: Vec4d, res: Vec4d = Vec4d()
        fun gaussRand(mean: Float, deviation: Float) = glm.gaussRand(mean, deviation)
        fun gaussRand(mean: Double, deviation: Double) = glm.gaussRand(mean, deviation)
        fun gaussRand(mean: Vec2, deviation: Vec2, res: Vec2 = Vec2()) = glm.gaussRand(mean: Vec2, deviation: Vec2, res: Vec2 = Vec2()
        fun gaussRand(mean: Vec2d, deviation: Vec2d, res: Vec2d = Vec2d()) = glm.gaussRand(mean: Vec2d, deviation: Vec2d, res: Vec2d = Vec2d()
        fun gaussRand(mean: Vec3, deviation: Vec3, res: Vec3 = Vec3()) = glm.gaussRand(mean: Vec3, deviation: Vec3, res: Vec3 = Vec3()
        fun gaussRand(mean: Vec3d, deviation: Vec3d, res: Vec3d = Vec3d()) = glm.gaussRand(mean: Vec3d, deviation: Vec3d, res: Vec3d = Vec3d()
        fun gaussRand(mean: Vec4, deviation: Vec4, res: Vec4 = Vec4()) = glm.gaussRand(mean: Vec4, deviation: Vec4, res: Vec4 = Vec4()
        fun gaussRand(mean: Vec4d, deviation: Vec4d, res: Vec4d = Vec4d()) = glm.gaussRand(mean: Vec4d, deviation: Vec4d, res: Vec4d = Vec4d()
        fun circularRand(radius: Float, res: Vec2 = Vec2()) = glm.circularRand(radius: Float, res: Vec2 = Vec2()
        fun circularRand(radius: Double, res: Vec2d = Vec2d()) = glm.circularRand(radius: Double, res: Vec2d = Vec2d()
        fun sphericalRand(radius: Float, res: Vec3 = Vec3()) = glm.sphericalRand(radius: Float, res: Vec3 = Vec3()
        fun sphericalRand(radius: Double, res: Vec3d = Vec3d()) = glm.sphericalRand(radius: Double, res: Vec3d = Vec3d()
        fun diskRand(radius: Float, res: Vec2 = Vec2()) = glm.diskRand(radius: Float, res: Vec2 = Vec2()
        fun diskRand(radius: Double, res: Vec2d = Vec2d()) = glm.diskRand(radius: Double, res: Vec2d = Vec2d()
        fun diskRand(radius: Float, res: Vec3 = Vec3()) = glm.diskRand(radius: Float, res: Vec3 = Vec3()
        fun diskRand(radius: Double, res: Vec3d = Vec3d()) = glm.diskRand(radius: Double, res: Vec3d = Vec3d()
        fun diskRand(radius: Float, res: Vec4 = Vec4()) = glm.diskRand(radius: Float, res: Vec4 = Vec4()
        fun diskRand(radius: Double, res: Vec4d = Vec4d()) = glm.diskRand(radius: Double, res: Vec4d = Vec4d()
        fun ballRand(radius: Float, res: Vec3 = Vec3()) = glm.ballRand(radius: Float, res: Vec3 = Vec3()
        fun ballRand(radius: Double, res: Vec3d = Vec3d()) = glm.ballRand(radius: Double, res: Vec3d = Vec3d()

        // file: dualQuat/DualQuatD.kt
        fun invoke(real: QuatD, dual: QuatD) = glm.invoke(real, dual)
        fun lerp(b: DualQuatD, a: Double, res: DualQuatD = DualQuatD()) = glm.lerp(b: DualQuatD, a: Double, res: DualQuatD = DualQuatD()
        fun inverse(res: DualQuatD = DualQuatD()) = glm.inverse(res: DualQuatD = DualQuatD()
        fun dualquat_cast(x: Mat2x4d, res: DualQuatD = DualQuatD()) = glm.dualquat_cast(x: Mat2x4d, res: DualQuatD = DualQuatD()
        fun dualquat_cast(m: Mat3x4d, res: DualQuatD = DualQuatD()) = glm.dualquat_cast(m: Mat3x4d, res: DualQuatD = DualQuatD()

        // file: dualQuat/DualQuat.kt
        fun invoke(real: Quat, dual: Quat) = glm.invoke(real, dual)
        fun lerp(b: DualQuat, a: Float, res: DualQuat = DualQuat()) = glm.lerp(b: DualQuat, a: Float, res: DualQuat = DualQuat()
        fun inverse(res: DualQuat = DualQuat()) = glm.inverse(res: DualQuat = DualQuat()
        fun dualquat_cast(x: Mat2x4, res: DualQuat = DualQuat()) = glm.dualquat_cast(x: Mat2x4, res: DualQuat = DualQuat()
        fun dualquat_cast(m: Mat3x4, res: DualQuat = DualQuat()) = glm.dualquat_cast(m: Mat3x4, res: DualQuat = DualQuat()

        // file: dualQuat/dualQuatD_operators.kt
        fun plus(res: DualQuatD, a: DualQuatD, b: DualQuatD) = glm.plus(res, a, b)
        fun minus(res: Quat, a: Quat, b: Quat) = glm.minus(res, a, b)
        fun times(res: DualQuatD, a: DualQuatD, b: DualQuatD) = glm.times(res, a, b)
        fun times(res: Vec3d, q: DualQuatD, v: Vec3d) = glm.times(res, q, v)
        fun times(res: Vec3d, v: Vec3d, q: DualQuatD) = glm.times(res, v, q)
        fun times(res: Vec4d, q: DualQuatD, v: Vec4d) = glm.times(res, q, v)
        fun times(res: Vec4d, v: Vec4d, q: DualQuatD) = glm.times(res, v, q)
        fun times(res: DualQuatD, q: DualQuatD, s: Double) = glm.times(res, q, s)
        fun div(res: DualQuatD, q: DualQuatD, s: Double) = glm.div(res, q, s)

        // file: dualQuat/dualQuat_operators.kt
        fun plus(res: DualQuat, a: DualQuat, b: DualQuat) = glm.plus(res, a, b)
        fun minus(res: Quat, a: Quat, b: Quat) = glm.minus(res, a, b)
        fun times(res: DualQuat, a: DualQuat, b: DualQuat) = glm.times(res, a, b)
        fun times(res: Vec3, q: DualQuat, v: Vec3) = glm.times(res, q, v)
        fun times(res: Vec3, v: Vec3, q: DualQuat) = glm.times(res, v, q)
        fun times(res: Vec4, q: DualQuat, v: Vec4) = glm.times(res, q, v)
        fun times(res: Vec4, v: Vec4, q: DualQuat) = glm.times(res, v, q)
        fun times(res: DualQuat, q: DualQuat, s: Float) = glm.times(res, q, s)
        fun div(res: DualQuat, q: DualQuat, s: Float) = glm.div(res, q, s)

        // file: gtx/gtxNormal.kt
        fun triangleNormal(p1: Vec3, p2: Vec3, p3: Vec3) = glm.triangleNormal()
        fun triangleNormal(res: Vec3, p1: Vec3, p2: Vec3, p3: Vec3) = glm.triangleNormal(res)
        fun triangleNormal(p1: Vec4, p2: Vec4, p3: Vec4) = glm.triangleNormal()
        fun triangleNormal(res: Vec4, p1: Vec4, p2: Vec4, p3: Vec4) = glm.triangleNormal(res)

        // file: gtx/gtxEasing.kt
        fun linearInterpolation(a: Float) = glm.linearInterpolation(a)
        fun quadraticEaseIn(a: Float) = glm.quadraticEaseIn(a)
        fun quadraticEaseOut(a: Float) = glm.quadraticEaseOut(a)
        fun quadraticEaseInOut(a: Float) = glm.quadraticEaseInOut(a)
        fun cubicEaseIn(a: Float) = glm.cubicEaseIn(a)
        fun cubicEaseOut(a: Float) = glm.cubicEaseOut(a)
        fun cubicEaseInOut(a: Float) = glm.cubicEaseInOut(a)
        fun quarticEaseIn(a: Float) = glm.quarticEaseIn(a)
        fun quarticEaseOut(a: Float) = glm.quarticEaseOut(a)
        fun quarticEaseInOut(a: Float) = glm.quarticEaseInOut(a)
        fun quinticEaseIn(a: Float) = glm.quinticEaseIn(a)
        fun quinticEaseOut(a: Float) = glm.quinticEaseOut(a)
        fun quinticEaseInOut(a: Float) = glm.quinticEaseInOut(a)
        fun sineEaseIn(a: Float) = glm.sineEaseIn(a)
        fun sineEaseOut(a: Float) = glm.sineEaseOut(a)
        fun sineEaseInOut(a: Float) = glm.sineEaseInOut(a)
        fun circularEaseIn(a: Float) = glm.circularEaseIn(a)
        fun circularEaseOut(a: Float) = glm.circularEaseOut(a)
        fun circularEaseInOut(a: Float) = glm.circularEaseInOut(a)
        fun exponentialEaseIn(a: Float) = glm.exponentialEaseIn(a)
        fun exponentialEaseOut(a: Float) = glm.exponentialEaseOut(a)
        fun exponentialEaseInOut(a: Float) = glm.exponentialEaseInOut(a)
        fun elasticEaseIn(a: Float) = glm.elasticEaseIn(a)
        fun elasticEaseOut(a: Float) = glm.elasticEaseOut(a)
        fun elasticEaseInOut(a: Float) = glm.elasticEaseInOut(a)
        fun backEaseIn(a: Float) = glm.backEaseIn(a)
        fun backEaseOut(a: Float) = glm.backEaseOut(a)
        fun backEaseInOut(a: Float) = glm.backEaseInOut(a)
        fun backEaseIn(a: Float, o: Float) = glm.backEaseIn(a, o)
        fun backEaseOut(a: Float, o: Float) = glm.backEaseOut(a, o)
        fun backEaseInOut(a: Float, o: Float) = glm.backEaseInOut(a, o)
        fun bounceEaseIn(a: Float) = glm.bounceEaseIn(a)
        fun bounceEaseOut(a: Float) = glm.bounceEaseOut(a)
        fun bounceEaseInOut(a: Float) = glm.bounceEaseInOut(a)

        // file: gtx/gtxInteger.kt
        fun floorLog2(x_: uint) = glm.floorLog2()
        fun factorial(x: Int) = glm.factorial(x)
        fun ones32(x_: uint) = glm.ones32()

        // file: gtx/gtxIntersect.kt
        fun intersectRayPlane(orig: Vec3, dir: Vec3, planeOrig: Vec3, planeNormal: Vec3) = glm.intersectRayPlane(orig, dir, rig, ormal)
        fun intersectRayTriangle(orig: Vec3, dir: Vec3, vert0: Vec3, vert1: Vec3, vert2: Vec3, baryPosition: Vec2) = glm.intersectRayTriangle(orig, dir, osition)
        fun intersectLineTriangle(orig: Vec3, dir: Vec3, vert0: Vec3, vert1: Vec3, vert2: Vec3, position: Vec3) = glm.intersectLineTriangle(orig, dir, position)
        fun intersectRaySphere(rayStarting: Vec3, rayNormalizedDirection: Vec3, sphereCenter: Vec3, sphereRadiusSquered: Float) = glm.intersectRaySphere(tarting, irection, enter, quered)

        // file: gtx/gtxFastTrigonometry.kt
        fun fastCos(angle_: Float) = glm.fastCos()
        fun fastAtan(y: Float, x: Float) = glm.fastAtan(y, x)
        fun cos52s(x: Float) = glm.cos52s(x)

        // file: gtx/matrixDecompose.kt
        fun decompose(modelMatrix: Mat4, scale: Vec3, orientation: Quat, translation: Vec3, skew: Vec3, perspective: Vec4) = glm.decompose(atrix, scale, orientation, translation, skew, perspective)

        // file: gtx/gtxMatrixFactorization.kt
        fun flipUD(`in`: Mat4) = glm.flipUD()
        fun flipLR(`in`: Mat4) = glm.flipLR()
        fun flipUD(`in`: Mat3) = glm.flipUD()
        fun flipLR(`in`: Mat3) = glm.flipLR()

        // file: gtx/gtxClosestPoint.kt
        fun closestPointOnLine(point: Vec3, a: Vec3, b: Vec3) = glm.closestPointOnLine(point, a, b)
        fun closestPointOnLine(point: Vec2, a: Vec2, b: Vec2) = glm.closestPointOnLine(point, a, b)

        // file: gtx/gtxRotateVector.kt
        fun slerp(res: Vec3, a: Vec3, b: Vec3, factor: Float) = glm.slerp(res, a, b, factor)
        fun rotate(res: Vec2, v: Vec2, angle: Float) = glm.rotate(res, v, angle)
        fun rotate(res: Vec3, v: Vec3, angle: Float, normal: Vec3, tmp: Mat4 = Mat4()) = glm.rotate(res: Vec3, v: Vec3, angle: Float, normal: Vec3, tmp: Mat4 = Mat4()
        fun rotate(res: Vec4, v: Vec4, angle: Float, normal: Vec3, tmp: Mat4 = Mat4()) = glm.rotate(res: Vec4, v: Vec4, angle: Float, normal: Vec3, tmp: Mat4 = Mat4()
        fun rotateX(res: Vec3, v: Vec3, angle: Float) = glm.rotateX(res, v, angle)
        fun rotateY(res: Vec3, v: Vec3, angle: Float) = glm.rotateY(res, v, angle)
        fun rotateZ(res: Vec3, v: Vec3, angle: Float) = glm.rotateZ(res, v, angle)
        fun rotateX(res: Vec4, v: Vec4, angle: Float) = glm.rotateX(res, v, angle)
        fun rotateY(res: Vec4, v: Vec4, angle: Float) = glm.rotateY(res, v, angle)
        fun rotateZ(res: Vec4, v: Vec4, angle: Float) = glm.rotateZ(res, v, angle)
        fun orientation(res: Mat4, normal: Vec3, up: Vec3, tmp: Vec3 = Vec3()) = glm.orientation(res: Mat4, normal: Vec3, up: Vec3, tmp: Vec3 = Vec3()

        // file: gtx/gtxVectorAngle.kt
        fun orientedAngle(x: Vec2, y: Vec2) = glm.orientedAngle(x, y)
        fun orientedAngle(x: Vec3, y: Vec3, ref: Vec3) = glm.orientedAngle(x, y, ref)

        // file: gtx/gtxEulerAngles.kt
        fun eulerAngleX(res: Mat4, angleX: Float) = glm.eulerAngleX(res)
        fun eulerAngleX(angleX: Float) = glm.eulerAngleX()
        fun eulerAngleY(res: Mat4, angleY: Float) = glm.eulerAngleY(res)
        fun eulerAngleY(angleY: Float) = glm.eulerAngleY()
        fun eulerAngleZ(res: Mat4, angleZ: Float) = glm.eulerAngleZ(res)
        fun eulerAngleZ(angleZ: Float) = glm.eulerAngleZ()
        fun derivedEulerAngleX(res: Mat4, angleX: Float, angularVelocityX: Float) = glm.derivedEulerAngleX(res)
        fun derivedEulerAngleX(angleX: Float, angularVelocityX: Float) = glm.derivedEulerAngleX()
        fun derivedEulerAngleY(res: Mat4, angleY: Float, angularVelocityY: Float) = glm.derivedEulerAngleY(res)
        fun derivedEulerAngleY(angleY: Float, angularVelocityY: Float) = glm.derivedEulerAngleY()
        fun derivedEulerAngleZ(res: Mat4, angleZ: Float, angularVelocityZ: Float) = glm.derivedEulerAngleZ(res)
        fun derivedEulerAngleZ(angleZ: Float, angularVelocityZ: Float) = glm.derivedEulerAngleZ()
        fun eulerAngleXY(res: Mat4, angleX: Float, angleY: Float) = glm.eulerAngleXY(res)
        fun eulerAngleXY(angleX: Float, angleY: Float) = glm.eulerAngleXY()
        fun eulerAngleYX(res: Mat4, angleY: Float, angleX: Float) = glm.eulerAngleYX(res)
        fun eulerAngleYX(angleY: Float, angleX: Float) = glm.eulerAngleYX()
        fun eulerAngleXZ(res: Mat4, angleX: Float, angleZ: Float) = glm.eulerAngleXZ(res)
        fun eulerAngleXZ(angleX: Float, angleZ: Float) = glm.eulerAngleXZ()
        fun eulerAngleZX(res: Mat4, angleZ: Float, angleX: Float) = glm.eulerAngleZX(res)
        fun eulerAngleZX(angleZ: Float, angleX: Float) = glm.eulerAngleZX()
        fun eulerAngleYZ(res: Mat4, angleY: Float, angleZ: Float) = glm.eulerAngleYZ(res)
        fun eulerAngleYZ(angleY: Float, angleZ: Float) = glm.eulerAngleYZ()
        fun eulerAngleZY(res: Mat4, angleZ: Float, angleY: Float) = glm.eulerAngleZY(res)
        fun eulerAngleZY(angleZ: Float, angleY: Float) = glm.eulerAngleZY()
        fun eulerAngleXYZ(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleXYZ(res)
        fun eulerAngleXYZ(t1: Float, t2: Float, t3: Float) = glm.eulerAngleXYZ()
        fun eulerAngleYXZ(res: Mat4, yaw: Float, pitch: Float, roll: Float) = glm.eulerAngleYXZ(res, yaw, pitch, roll)
        fun eulerAngleYXZ(yaw: Float, pitch: Float, roll: Float) = glm.eulerAngleYXZ(yaw, pitch, roll)
        fun eulerAngleXZX(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleXZX(res)
        fun eulerAngleXZX(t1: Float, t2: Float, t3: Float) = glm.eulerAngleXZX()
        fun eulerAngleXYX(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleXYX(res)
        fun eulerAngleXYX(t1: Float, t2: Float, t3: Float) = glm.eulerAngleXYX()
        fun eulerAngleYXY(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleYXY(res)
        fun eulerAngleYXY(t1: Float, t2: Float, t3: Float) = glm.eulerAngleYXY()
        fun eulerAngleYZY(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleYZY(res)
        fun eulerAngleYZY(t1: Float, t2: Float, t3: Float) = glm.eulerAngleYZY()
        fun eulerAngleZYZ(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleZYZ(res)
        fun eulerAngleZYZ(t1: Float, t2: Float, t3: Float) = glm.eulerAngleZYZ()
        fun eulerAngleZXZ(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleZXZ(res)
        fun eulerAngleZXZ(t1: Float, t2: Float, t3: Float) = glm.eulerAngleZXZ()
        fun eulerAngleXZY(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleXZY(res)
        fun eulerAngleXZY(t1: Float, t2: Float, t3: Float) = glm.eulerAngleXZY()
        fun eulerAngleYZX(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleYZX(res)
        fun eulerAngleYZX(t1: Float, t2: Float, t3: Float) = glm.eulerAngleYZX()
        fun eulerAngleZYX(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleZYX(res)
        fun eulerAngleZYX(t1: Float, t2: Float, t3: Float) = glm.eulerAngleZYX()
        fun eulerAngleZXY(res: Mat4, t1: Float, t2: Float, t3: Float) = glm.eulerAngleZXY(res)
        fun eulerAngleZXY(t1: Float, t2: Float, t3: Float) = glm.eulerAngleZXY()
        fun yawPitchRoll(res: Mat4, yaw: Float, pitch: Float, roll: Float) = glm.yawPitchRoll(res, yaw, pitch, roll)
        fun yawPitchRoll(yaw: Float, pitch: Float, roll: Float) = glm.yawPitchRoll(yaw, pitch, roll)
        fun yawPitchRoll(block: (Int) -> Float) = glm.yawPitchRoll(block: ()
        fun orientate2(res: Mat2, angle: Float) = glm.orientate2(res, angle)
        fun orientate2(angle: Float) = glm.orientate2(angle)
        fun orientate3(res: Mat3, angle: Float) = glm.orientate3(res, angle)
        fun orientate3(angle: Float) = glm.orientate3(angle)
        fun orientate3(res: Mat3, angles: Vec3) = glm.orientate3(res, angles)
        fun orientate3(angles: Vec3) = glm.orientate3(angles)
        fun orientate4(res: Mat4, angles: Vec3) = glm.orientate4(res, angles)
        fun orientate4(angles: Vec3) = glm.orientate4(angles)
        fun extractEulerAngleXYZ(res: Vec3, m: Mat4) = glm.extractEulerAngleXYZ(res, m)
        fun extractEulerAngleXYZ(m: Mat4) = glm.extractEulerAngleXYZ(m)
        fun extractEulerAngleYXZ(res: Vec3, m: Mat4) = glm.extractEulerAngleYXZ(res, m)
        fun extractEulerAngleYXZ(m: Mat4) = glm.extractEulerAngleYXZ(m)
        fun extractEulerAngleXZX(res: Vec3, m: Mat4) = glm.extractEulerAngleXZX(res, m)
        fun extractEulerAngleXZX(m: Mat4) = glm.extractEulerAngleXZX(m)
        fun extractEulerAngleXYX(res: Vec3, m: Mat4) = glm.extractEulerAngleXYX(res, m)
        fun extractEulerAngleXYX(m: Mat4) = glm.extractEulerAngleXYX(m)
        fun extractEulerAngleYXY(res: Vec3, m: Mat4) = glm.extractEulerAngleYXY(res, m)
        fun extractEulerAngleYXY(m: Mat4) = glm.extractEulerAngleYXY(m)
        fun extractEulerAngleYZY(res: Vec3, m: Mat4) = glm.extractEulerAngleYZY(res, m)
        fun extractEulerAngleYZY(m: Mat4) = glm.extractEulerAngleYZY(m)
        fun extractEulerAngleZYZ(res: Vec3, m: Mat4) = glm.extractEulerAngleZYZ(res, m)
        fun extractEulerAngleZYZ(m: Mat4) = glm.extractEulerAngleZYZ(m)
        fun extractEulerAngleZXZ(res: Vec3, m: Mat4) = glm.extractEulerAngleZXZ(res, m)
        fun extractEulerAngleZXZ(m: Mat4) = glm.extractEulerAngleZXZ(m)
        fun extractEulerAngleXZY(res: Vec3, m: Mat4) = glm.extractEulerAngleXZY(res, m)
        fun extractEulerAngleXZY(m: Mat4) = glm.extractEulerAngleXZY(m)
        fun extractEulerAngleYZX(res: Vec3, m: Mat4) = glm.extractEulerAngleYZX(res, m)
        fun extractEulerAngleYZX(m: Mat4) = glm.extractEulerAngleYZX(m)
        fun extractEulerAngleZYX(res: Vec3, m: Mat4) = glm.extractEulerAngleZYX(res, m)
        fun extractEulerAngleZYX(m: Mat4) = glm.extractEulerAngleZYX(m)
        fun extractEulerAngleZXY(res: Vec3, m: Mat4) = glm.extractEulerAngleZXY(res, m)
        fun extractEulerAngleZXY(m: Mat4) = glm.extractEulerAngleZXY(m)

        // file: gtx/gtxSpline.kt
        fun catmullRom(v1: Vec2, v2: Vec2, v3: Vec2, v4: Vec2, s: Float) = glm.catmullRom(s)
        fun catmullRom(v1: Vec3, v2: Vec3, v3: Vec3, v4: Vec3, s: Float) = glm.catmullRom(s)
        fun catmullRom(v1: Vec4, v2: Vec4, v3: Vec4, v4: Vec4, s: Float) = glm.catmullRom(s)
        fun hermite(v1: Vec1, t1: Vec1, v2: Vec1, t2: Vec1, s: Float) = glm.hermite(s)
        fun hermite(v1: Vec2, t1: Vec2, v2: Vec2, t2: Vec2, s: Float) = glm.hermite(s)
        fun hermite(v1: Vec3, t1: Vec3, v2: Vec3, t2: Vec3, s: Float) = glm.hermite(s)
        fun hermite(v1: Vec4, t1: Vec4, v2: Vec4, t2: Vec4, s: Float) = glm.hermite(s)
        fun cubic(v1: Vec1, v2: Vec1, v3: Vec1, v4: Vec1, s: Float) = glm.cubic(s)
        fun cubic(v1: Vec2, v2: Vec2, v3: Vec2, v4: Vec2, s: Float) = glm.cubic(s)
        fun cubic(v1: Vec3, v2: Vec3, v3: Vec3, v4: Vec3, s: Float) = glm.cubic(s)
        fun cubic(v1: Vec4, v2: Vec4, v3: Vec4, v4: Vec4, s: Float) = glm.cubic(s)

        // file: gtx/gtxMatrixCrossProduct.kt
        fun matrixCross3(res: Mat3, x: Vec3) = glm.matrixCross3(res, x)
        fun matrixCross3(x: Vec3) = glm.matrixCross3(x)
        fun matrixCross4(res: Mat4, x: Vec3) = glm.matrixCross4(res, x)
        fun matrixCross4(x: Vec3) = glm.matrixCross4(x)

        // file: noise.kt
        fun grad4(j: Float, ip: Vec4) = glm.grad4(j, ip)
        fun perlin(position: Vec2) = glm.perlin(position)
        fun perlin(position: Vec3) = glm.perlin(position)
        fun perlin(position: Vec4) = glm.perlin(position)
        fun perlin(position: Vec2, rep: Vec2) = glm.perlin(position, rep)
        fun perlin(position: Vec3, rep: Vec3) = glm.perlin(position, rep)
        fun perlin(position: Vec4, rep: Vec4) = glm.perlin(position, rep)
        fun simplex(v: Vec2) = glm.simplex(v)
        fun simplex(v: Vec3) = glm.simplex(v)
        fun simplex(v: Vec4) = glm.simplex(v)

        // file: extensions.kt
        fun ByteArray.getShort(index: Int, bigEndian: Boolean = true) = glm.ByteArray.getShort(index, ndian)
        fun ByteArray.getInt(index: Int, bigEndian: Boolean = true) = glm.ByteArray.getInt(index, ndian)
        fun ByteArray.getLong(index: Int, bigEndian: Boolean = true) = glm.ByteArray.getLong(index, ndian)
        fun InputStream.int(bigEndian: Boolean = true) = glm.InputStream.int(ndian)
        fun InputStream.short(bigEndian: Boolean = true) = glm.InputStream.short(ndian)
        fun InputStream.long(bigEndian: Boolean = true) = glm.InputStream.long(ndian)

        // file: mat3x4/Mat3x4t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: mat3x4/Mat3x4d.kt
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)

        // file: mat3x4/Mat3x4.kt
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)

        // file: gtc/gtcMatrixInverse.kt
        fun inverseTranspose(res: Mat2, m: Mat2) = glm.inverseTranspose(res, m)
        fun inverseTranspose(res: Mat2d, m: Mat2d) = glm.inverseTranspose(res, m)
        fun inverseTranspose(res: Mat3, m: Mat3) = glm.inverseTranspose(res, m)
        fun inverseTranspose(res: Mat3d, m: Mat3d) = glm.inverseTranspose(res, m)
        fun inverseTranspose(res: Mat4, m: Mat4) = glm.inverseTranspose(res, m)
        fun inverseTranspose(res: Mat4d, m: Mat4d) = glm.inverseTranspose(res, m)

        // file: gtc/matrixTransform/gtcMatrixFrustum.kt
        fun frustumLhZo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumLhZo(res, left, right, bottom, top, near, far)
        fun frustumLhZo(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumLhZo(left, right, bottom, top, near, far)
        fun frustumLhNo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumLhNo(res, left, right, bottom, top, near, far)
        fun frustumLhNo(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumLhNo(left, right, bottom, top, near, far)
        fun frustumRhZo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumRhZo(res, left, right, bottom, top, near, far)
        fun frustumRhZo(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumRhZo(left, right, bottom, top, near, far)
        fun frustumRhNo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumRhNo(res, left, right, bottom, top, near, far)
        fun frustumRhNo(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumRhNo(left, right, bottom, top, near, far)
        fun frustumZo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumZo(res, left, right, bottom, top, near, far)
        fun frustumZo(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumZo(left, right, bottom, top, near, far)
        fun frustumNo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumNo(res, left, right, bottom, top, near, far)
        fun frustumNo(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumNo(left, right, bottom, top, near, far)
        fun frustumLh(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumLh(res, left, right, bottom, top, near, far)
        fun frustumLh(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumLh(left, right, bottom, top, near, far)
        fun frustumRh(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumRh(res, left, right, bottom, top, near, far)
        fun frustumRh(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustumRh(left, right, bottom, top, near, far)
        fun frustum(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustum(res, left, right, bottom, top, near, far)
        fun frustum(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) = glm.frustum(left, right, bottom, top, near, far)
        fun frustumLhZo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumLhZo(res, left, right, bottom, top, near, far)
        fun frustumLhZo(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumLhZo(left, right, bottom, top, near, far)
        fun frustumLhNo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumLhNo(res, left, right, bottom, top, near, far)
        fun frustumLhNo(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumLhNo(left, right, bottom, top, near, far)
        fun frustumRhZo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumRhZo(res, left, right, bottom, top, near, far)
        fun frustumRhZo(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumRhZo(left, right, bottom, top, near, far)
        fun frustumRhNo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumRhNo(res, left, right, bottom, top, near, far)
        fun frustumRhNo(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumRhNo(left, right, bottom, top, near, far)
        fun frustumZo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumZo(res, left, right, bottom, top, near, far)
        fun frustumZo(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumZo(left, right, bottom, top, near, far)
        fun frustumNo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumNo(res, left, right, bottom, top, near, far)
        fun frustumNo(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumNo(left, right, bottom, top, near, far)
        fun frustumLh(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumLh(res, left, right, bottom, top, near, far)
        fun frustumLh(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumLh(left, right, bottom, top, near, far)
        fun frustumRh(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumRh(res, left, right, bottom, top, near, far)
        fun frustumRh(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustumRh(left, right, bottom, top, near, far)
        fun frustum(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustum(res, left, right, bottom, top, near, far)
        fun frustum(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) = glm.frustum(left, right, bottom, top, near, far)

        // file: gtc/matrixTransform/gtcMatrixScale.kt
        fun scale(res: Mat4, m: Mat4, vX: Float, vY: Float, vZ: Float) = glm.scale(res, m)
        fun scale(res: Mat4, m: Mat4, v: Vec3) = glm.scale(res, m, v)
        fun scale(m: Mat4, vX: Float, vY: Float, vZ: Float) = glm.scale(m)
        fun scale(m: Mat4, v: Vec3) = glm.scale(m, v)
        fun scale(res: Mat4d, m: Mat4d, vX: Double, vY: Double, vZ: Double) = glm.scale(res, m)
        fun scale(res: Mat4d, m: Mat4d, v: Vec3d) = glm.scale(res, m, v)
        fun scale(m: Mat4d, vX: Double, vY: Double, vZ: Double) = glm.scale(m)
        fun scale(m: Mat4d, v: Vec3d) = glm.scale(m, v)
        fun scale(res: Mat3, m: Mat3, vX: Float, vY: Float, vZ: Float) = glm.scale(res, m)
        fun scale(res: Mat3, m: Mat3, v: Vec3) = glm.scale(res, m, v)
        fun scale(m: Mat3, vX: Float, vY: Float, vZ: Float) = glm.scale(m)
        fun scale(m: Mat3, v: Vec3) = glm.scale(m, v)
        fun scale(res: Mat3d, m: Mat3d, vX: Double, vY: Double, vZ: Double) = glm.scale(res, m)
        fun scale(res: Mat3d, m: Mat3d, v: Vec3d) = glm.scale(res, m, v)
        fun scale(m: Mat3d, vX: Double, vY: Double, vZ: Double) = glm.scale(m)
        fun scale(m: Mat3d, v: Vec3d) = glm.scale(m, v)

        // file: gtc/matrixTransform/gtcMatrixOrtho.kt
        fun ortho(res: Mat4, left: Float, right: Float, bottom: Float, top: Float) = glm.ortho(res, left, right, bottom, top)
        fun ortho(left: Float, right: Float, bottom: Float, top: Float) = glm.ortho(left, right, bottom, top)
        fun orthoLhZo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoLhZo(res, left, right, bottom, top, ear, ar)
        fun orthoLhZo(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoLhZo(left, right, bottom, top, ear, ar)
        fun orthoLhNo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoLhNo(res, left, right, bottom, top, ear, ar)
        fun orthoLhNo(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoLhNo(left, right, bottom, top, ear, ar)
        fun orthoRhZo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoRhZo(res, left, right, bottom, top, ear, ar)
        fun orthoRhZo(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoRhZo(left, right, bottom, top, ear, ar)
        fun orthoRhNo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoRhNo(res, left, right, bottom, top, ear, ar)
        fun orthoRhNo(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoRhNo(left, right, bottom, top, ear, ar)
        fun orthoZo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoZo(res, left, right, bottom, top, ear, ar)
        fun orthoZo(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoZo(left, right, bottom, top, ear, ar)
        fun orthoNo(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoNo(res, left, right, bottom, top, ear, ar)
        fun orthoNo(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoNo(left, right, bottom, top, ear, ar)
        fun orthoLh(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoLh(res, left, right, bottom, top, ear, ar)
        fun orthoLh(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoLh(left, right, bottom, top, ear, ar)
        fun orthoRh(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoRh(res, left, right, bottom, top, ear, ar)
        fun orthoRh(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.orthoRh(left, right, bottom, top, ear, ar)
        fun ortho(res: Mat4, left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.ortho(res, left, right, bottom, top, ear, ar)
        fun ortho(left: Float, right: Float, bottom: Float, top: Float, zNear: Float, zFar: Float) = glm.ortho(left, right, bottom, top, ear, ar)
        fun ortho(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double) = glm.ortho(res, left, right, bottom, top)
        fun ortho(left: Double, right: Double, bottom: Double, top: Double) = glm.ortho(left, right, bottom, top)
        fun orthoLhZo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoLhZo(res, left, right, bottom, top, ear, ar)
        fun orthoLhZo(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoLhZo(left, right, bottom, top, ear, ar)
        fun orthoLhNo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoLhNo(res, left, right, bottom, top, ear, ar)
        fun orthoLhNo(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoLhNo(left, right, bottom, top, ear, ar)
        fun orthoRhZo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoRhZo(res, left, right, bottom, top, ear, ar)
        fun orthoRhZo(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoRhZo(left, right, bottom, top, ear, ar)
        fun orthoRhNo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoRhNo(res, left, right, bottom, top, ear, ar)
        fun orthoRhNo(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoRhNo(left, right, bottom, top, ear, ar)
        fun orthoZo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoZo(res, left, right, bottom, top, ear, ar)
        fun orthoZo(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoZo(left, right, bottom, top, ear, ar)
        fun orthoNo(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoNo(res, left, right, bottom, top, ear, ar)
        fun orthoNo(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoNo(left, right, bottom, top, ear, ar)
        fun orthoLh(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoLh(res, left, right, bottom, top, ear, ar)
        fun orthoLh(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoLh(left, right, bottom, top, ear, ar)
        fun orthoRh(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoRh(res, left, right, bottom, top, ear, ar)
        fun orthoRh(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.orthoRh(left, right, bottom, top, ear, ar)
        fun ortho(res: Mat4d, left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.ortho(res, left, right, bottom, top, ear, ar)
        fun ortho(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double) = glm.ortho(left, right, bottom, top, ear, ar)

        // file: gtc/matrixTransform/gtcMatrixRotate.kt
        fun rotate(res: Mat4, m: Mat4, angle: Float, axisX: Float, axisY: Float, axisZ: Float) = glm.rotate(res, m, angle)
        fun rotate(res: Mat4, m: Mat4, angle: Float, axis: Vec3) = glm.rotate(res, m, angle, axis)
        fun rotate(m: Mat4, angle: Float, axisX: Float, axisY: Float, axisZ: Float) = glm.rotate(m, angle)
        fun rotate(m: Mat4, angle: Float, axis: Vec3) = glm.rotate(m, angle, axis)
        fun rotateX(res: Mat3, mat: Mat3, angle: Float) = glm.rotateX(res, mat, angle)
        fun rotateX(mat: Mat3, angle: Float) = glm.rotateX(mat, angle)
        fun rotateY(res: Mat3, mat: Mat3, angle: Float) = glm.rotateY(res, mat, angle)
        fun rotateY(mat: Mat3, angle: Float) = glm.rotateY(mat, angle)
        fun rotateZ(res: Mat3, mat: Mat3, angle: Float) = glm.rotateZ(res, mat, angle)
        fun rotateZ(mat: Mat3, angle: Float) = glm.rotateZ(mat, angle)
        fun rotateXYZ(res: Mat3, mat: Mat3, angleX: Float, angleY: Float, angleZ: Float) = glm.rotateXYZ(res, mat)
        fun rotateXYZ(mat: Mat3, angleX: Float, angleY: Float, angleZ: Float) = glm.rotateXYZ(mat)
        fun rotateX(res: Mat4, mat: Mat4, angle: Float) = glm.rotateX(res, mat, angle)
        fun rotateX(mat: Mat4, angle: Float) = glm.rotateX(mat, angle)
        fun rotateY(res: Mat4, mat: Mat4, angle: Float) = glm.rotateY(res, mat, angle)
        fun rotateY(mat: Mat4, angle: Float) = glm.rotateY(mat, angle)
        fun rotateZ(res: Mat4, mat: Mat4, angle: Float) = glm.rotateZ(res, mat, angle)
        fun rotateZ(mat: Mat4, angle: Float) = glm.rotateZ(mat, angle)
        fun rotateXYZ(res: Mat4, mat: Mat4, angleX: Float, angleY: Float, angleZ: Float) = glm.rotateXYZ(res, mat)
        fun rotateXYZ(mat: Mat4, angleX: Float, angleY: Float, angleZ: Float) = glm.rotateXYZ(mat)
        fun rotate(res: Mat4d, m: Mat4d, angle: Double, axisX: Double, axisY: Double, axisZ: Double) = glm.rotate(res, m, angle)
        fun rotate(res: Mat4d, m: Mat4d, angle: Double, axis: Vec3d) = glm.rotate(res, m, angle, axis)
        fun rotate(m: Mat4d, angle: Double, axisX: Double, axisY: Double, axisZ: Double) = glm.rotate(m, angle)
        fun rotate(m: Mat4d, angle: Double, axis: Vec3d) = glm.rotate(m, angle, axis)
        fun rotateX(res: Mat3d, mat: Mat3d, angle: Double) = glm.rotateX(res, mat, angle)
        fun rotateX(mat: Mat3d, angle: Double) = glm.rotateX(mat, angle)
        fun rotateY(res: Mat3d, mat: Mat3d, angle: Double) = glm.rotateY(res, mat, angle)
        fun rotateY(mat: Mat3d, angle: Double) = glm.rotateY(mat, angle)
        fun rotateZ(res: Mat3d, mat: Mat3d, angle: Double) = glm.rotateZ(res, mat, angle)
        fun rotateZ(mat: Mat3d, angle: Double) = glm.rotateZ(mat, angle)
        fun rotateXYZ(res: Mat3d, mat: Mat3d, angleX: Double, angleY: Double, angleZ: Double) = glm.rotateXYZ(res, mat)
        fun rotateXYZ(mat: Mat3d, angleX: Double, angleY: Double, angleZ: Double) = glm.rotateXYZ(mat)
        fun rotateX(res: Mat4d, mat: Mat4d, angle: Double) = glm.rotateX(res, mat, angle)
        fun rotateX(mat: Mat4d, angle: Double) = glm.rotateX(mat, angle)
        fun rotateY(res: Mat4d, mat: Mat4d, angle: Double) = glm.rotateY(res, mat, angle)
        fun rotateY(mat: Mat4d, angle: Double) = glm.rotateY(mat, angle)
        fun rotateZ(res: Mat4d, mat: Mat4d, angle: Double) = glm.rotateZ(res, mat, angle)
        fun rotateZ(mat: Mat4d, angle: Double) = glm.rotateZ(mat, angle)
        fun rotateXYZ(res: Mat4d, mat: Mat4d, angleX: Double, angleY: Double, angleZ: Double) = glm.rotateXYZ(res, mat)
        fun rotateXYZ(mat: Mat4d, angleX: Double, angleY: Double, angleZ: Double) = glm.rotateXYZ(mat)
        fun rotateXYZ(angleX: Float, angleY: Float, angleZ: Float, res: Mat3) = glm.rotateXYZ(res)
        fun rotateXYZ(angleX: Float, angleY: Float, angleZ: Float) = glm.rotateXYZ()

        // file: gtc/matrixTransform/gtcMatrixTransform.kt
        fun pickMatrix(res: Mat4, center: Vec2, delta: Vec2, viewport: Vec4i) = glm.pickMatrix(res, center, delta, viewport)
        fun pickMatrix(center: Vec2, delta: Vec2, viewport: Vec4i) = glm.pickMatrix(center, delta, viewport)
        fun lookAtRh(res: Mat4, eye: Vec3, center: Vec3, up: Vec3) = glm.lookAtRh(res, eye, center, up)
        fun lookAtRh(eye: Vec3, center: Vec3, up: Vec3) = glm.lookAtRh(eye, center, up)
        fun lookAtLh(res: Mat4, eye: Vec3, center: Vec3, up: Vec3) = glm.lookAtLh(res, eye, center, up)
        fun lookAtLh(eye: Vec3, center: Vec3, up: Vec3) = glm.lookAtLh(eye, center, up)
        fun lookAt(res: Mat4, eye: Vec3, center: Vec3, up: Vec3) = glm.lookAt(res, eye, center, up)
        fun lookAt(eye: Vec3, center: Vec3, up: Vec3) = glm.lookAt(eye, center, up)
        fun pickMatrix(res: Mat4d, center: Vec2d, delta: Vec2d, viewport: Vec4i) = glm.pickMatrix(res, center, delta, viewport)
        fun pickMatrix(center: Vec2d, delta: Vec2d, viewport: Vec4i) = glm.pickMatrix(center, delta, viewport)
        fun lookAtRh(res: Mat4d, eye: Vec3d, center: Vec3d, up: Vec3d) = glm.lookAtRh(res, eye, center, up)
        fun lookAtRh(eye: Vec3d, center: Vec3d, up: Vec3d) = glm.lookAtRh(eye, center, up)
        fun lookAtLh(res: Mat4d, eye: Vec3d, center: Vec3d, up: Vec3d) = glm.lookAtLh(res, eye, center, up)
        fun lookAtLh(eye: Vec3d, center: Vec3d, up: Vec3d) = glm.lookAtLh(eye, center, up)
        fun lookAt(res: Mat4d, eye: Vec3d, center: Vec3d, up: Vec3d) = glm.lookAt(res, eye, center, up)
        fun lookAt(eye: Vec3d, center: Vec3d, up: Vec3d) = glm.lookAt(eye, center, up)

        // file: gtc/matrixTransform/gtcMatrixPerspective.kt
        fun perspectiveRhZo(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveRhZo(res, aspect, near, far)
        fun perspectiveRhZo(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveRhZo(aspect, near, far)
        fun perspectiveRhNo(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveRhNo(res, aspect, near, far)
        fun perspectiveRhNo(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveRhNo(aspect, near, far)
        fun perspectiveLhZo(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveLhZo(res, aspect, near, far)
        fun perspectiveLhZo(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveLhZo(aspect, near, far)
        fun perspectiveLhNo(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveLhNo(res, aspect, near, far)
        fun perspectiveLhNo(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveLhNo(aspect, near, far)
        fun perspectiveZo(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveZo(res, aspect, near, far)
        fun perspectiveZo(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveZo(aspect, near, far)
        fun perspectiveNo(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveNo(res, aspect, near, far)
        fun perspectiveNo(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveNo(aspect, near, far)
        fun perspectiveRh(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveRh(res, aspect, near, far)
        fun perspectiveRh(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveRh(aspect, near, far)
        fun perspectiveLh(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveLh(res, aspect, near, far)
        fun perspectiveLh(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspectiveLh(aspect, near, far)
        fun perspective(res: Mat4, fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspective(res, aspect, near, far)
        fun perspective(fovY: Float, aspect: Float, near: Float, far: Float) = glm.perspective(aspect, near, far)
        fun perspectiveFovRhZo(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovRhZo(res, fov, width, height, near, far)
        fun perspectiveFovRhZo(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovRhZo(fov, width, height, near, far)
        fun perspectiveFovRhZo(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovRhZo(res, fov, size, near, far)
        fun perspectiveFovRhZo(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovRhZo(fov, size, near, far)
        fun perspectiveFovRhNo(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovRhNo(res, fov, width, height, near, far)
        fun perspectiveFovRhNo(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovRhNo(fov, width, height, near, far)
        fun perspectiveFovRhNo(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovRhNo(res, fov, size, near, far)
        fun perspectiveFovRhNo(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovRhNo(fov, size, near, far)
        fun perspectiveFovLhZo(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovLhZo(res, fov, width, height, near, far)
        fun perspectiveFovLhZo(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovLhZo(fov, width, height, near, far)
        fun perspectiveFovLhZo(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovLhZo(res, fov, size, near, far)
        fun perspectiveFovLhZo(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovLhZo(fov, size, near, far)
        fun perspectiveFovLhNo(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovLhNo(res, fov, width, height, near, far)
        fun perspectiveFovLhNo(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovLhNo(fov, width, height, near, far)
        fun perspectiveFovLhNo(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovLhNo(res, fov, size, near, far)
        fun perspectiveFovLhNo(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovLhNo(fov, size, near, far)
        fun perspectiveFovZo(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovZo(res, fov, width, height, near, far)
        fun perspectiveFovZo(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovZo(fov, width, height, near, far)
        fun perspectiveFovZo(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovZo(res, fov, size, near, far)
        fun perspectiveFovZo(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovZo(fov, size, near, far)
        fun perspectiveFovNo(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovNo(res, fov, width, height, near, far)
        fun perspectiveFovNo(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovNo(fov, width, height, near, far)
        fun perspectiveFovNo(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovNo(res, fov, size, near, far)
        fun perspectiveFovNo(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovNo(fov, size, near, far)
        fun perspectiveFovRh(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovRh(res, fov, width, height, near, far)
        fun perspectiveFovRh(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovRh(fov, width, height, near, far)
        fun perspectiveFovRh(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovRh(res, fov, size, near, far)
        fun perspectiveFovRh(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovRh(fov, size, near, far)
        fun perspectiveFovLh(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovLh(res, fov, width, height, near, far)
        fun perspectiveFovLh(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFovLh(fov, width, height, near, far)
        fun perspectiveFovLh(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovLh(res, fov, size, near, far)
        fun perspectiveFovLh(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFovLh(fov, size, near, far)
        fun perspectiveFov(res: Mat4, fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFov(res, fov, width, height, near, far)
        fun perspectiveFov(fov: Float, width: Float, height: Float, near: Float, far: Float) = glm.perspectiveFov(fov, width, height, near, far)
        fun perspectiveFov(res: Mat4, fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFov(res, fov, size, near, far)
        fun perspectiveFov(fov: Float, size: Vec2t<*>, near: Float, far: Float) = glm.perspectiveFov(fov, size, near, far)
        fun infinitePerspectiveLh(res: Mat4, fovY: Float, aspect: Float, near: Float) = glm.infinitePerspectiveLh(res, aspect, near)
        fun infinitePerspectiveLh(fovY: Float, aspect: Float, near: Float) = glm.infinitePerspectiveLh(aspect, near)
        fun infinitePerspectiveRh(res: Mat4, fovY: Float, aspect: Float, near: Float) = glm.infinitePerspectiveRh(res, aspect, near)
        fun infinitePerspectiveRh(fovY: Float, aspect: Float, near: Float) = glm.infinitePerspectiveRh(aspect, near)
        fun infinitePerspective(res: Mat4, fovY: Float, aspect: Float, near: Float) = glm.infinitePerspective(res, aspect, near)
        fun infinitePerspective(fovY: Float, aspect: Float, near: Float) = glm.infinitePerspective(aspect, near)
        fun tweakedInfinitePerspective(res: Mat4, fovY: Float, aspect: Float, near: Float) = glm.tweakedInfinitePerspective(res, aspect, near)
        fun tweakedInfinitePerspective(res: Mat4, fovY: Float, aspect: Float, near: Float, ep: Float) = glm.tweakedInfinitePerspective(res, aspect, near, ep)
        fun tweakedInfinitePerspective(fovY: Float, aspect: Float, near: Float) = glm.tweakedInfinitePerspective(aspect, near)
        fun tweakedInfinitePerspective(fovY: Float, aspect: Float, near: Float, ep: Float) = glm.tweakedInfinitePerspective(aspect, near, ep)
        fun perspectiveRhZo(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveRhZo(res, aspect, near, far)
        fun perspectiveRhZo(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveRhZo(aspect, near, far)
        fun perspectiveRhNo(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveRhNo(res, aspect, near, far)
        fun perspectiveRhNo(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveRhNo(aspect, near, far)
        fun perspectiveLhZo(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveLhZo(res, aspect, near, far)
        fun perspectiveLhZo(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveLhZo(aspect, near, far)
        fun perspectiveLhNo(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveLhNo(res, aspect, near, far)
        fun perspectiveLhNo(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveLhNo(aspect, near, far)
        fun perspectiveZo(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveZo(res, aspect, near, far)
        fun perspectiveZo(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveZo(aspect, near, far)
        fun perspectiveNo(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveNo(res, aspect, near, far)
        fun perspectiveNo(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveNo(aspect, near, far)
        fun perspectiveRh(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveRh(res, aspect, near, far)
        fun perspectiveRh(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveRh(aspect, near, far)
        fun perspectiveLh(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveLh(res, aspect, near, far)
        fun perspectiveLh(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspectiveLh(aspect, near, far)
        fun perspective(res: Mat4d, fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspective(res, aspect, near, far)
        fun perspective(fovY: Double, aspect: Double, near: Double, far: Double) = glm.perspective(aspect, near, far)
        fun perspectiveFovRhZo(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovRhZo(res, fov, width, height, near, far)
        fun perspectiveFovRhZo(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovRhZo(fov, width, height, near, far)
        fun perspectiveFovRhZo(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovRhZo(res, fov, size, near, far)
        fun perspectiveFovRhZo(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovRhZo(fov, size, near, far)
        fun perspectiveFovRhNo(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovRhNo(res, fov, width, height, near, far)
        fun perspectiveFovRhNo(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovRhNo(fov, width, height, near, far)
        fun perspectiveFovRhNo(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovRhNo(res, fov, size, near, far)
        fun perspectiveFovRhNo(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovRhNo(fov, size, near, far)
        fun perspectiveFovLhZo(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovLhZo(res, fov, width, height, near, far)
        fun perspectiveFovLhZo(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovLhZo(fov, width, height, near, far)
        fun perspectiveFovLhZo(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovLhZo(res, fov, size, near, far)
        fun perspectiveFovLhZo(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovLhZo(fov, size, near, far)
        fun perspectiveFovLhNo(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovLhNo(res, fov, width, height, near, far)
        fun perspectiveFovLhNo(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovLhNo(fov, width, height, near, far)
        fun perspectiveFovLhNo(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovLhNo(res, fov, size, near, far)
        fun perspectiveFovLhNo(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovLhNo(fov, size, near, far)
        fun perspectiveFovZo(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovZo(res, fov, width, height, near, far)
        fun perspectiveFovZo(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovZo(fov, width, height, near, far)
        fun perspectiveFovZo(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovZo(res, fov, size, near, far)
        fun perspectiveFovZo(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovZo(fov, size, near, far)
        fun perspectiveFovNo(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovNo(res, fov, width, height, near, far)
        fun perspectiveFovNo(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovNo(fov, width, height, near, far)
        fun perspectiveFovNo(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovNo(res, fov, size, near, far)
        fun perspectiveFovNo(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovNo(fov, size, near, far)
        fun perspectiveFovRh(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovRh(res, fov, width, height, near, far)
        fun perspectiveFovRh(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovRh(fov, width, height, near, far)
        fun perspectiveFovRh(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovRh(res, fov, size, near, far)
        fun perspectiveFovRh(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovRh(fov, size, near, far)
        fun perspectiveFovLh(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovLh(res, fov, width, height, near, far)
        fun perspectiveFovLh(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFovLh(fov, width, height, near, far)
        fun perspectiveFovLh(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovLh(res, fov, size, near, far)
        fun perspectiveFovLh(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFovLh(fov, size, near, far)
        fun perspectiveFov(res: Mat4d, fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFov(res, fov, width, height, near, far)
        fun perspectiveFov(fov: Double, width: Double, height: Double, near: Double, far: Double) = glm.perspectiveFov(fov, width, height, near, far)
        fun perspectiveFov(res: Mat4d, fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFov(res, fov, size, near, far)
        fun perspectiveFov(fov: Double, size: Vec2t<*>, near: Double, far: Double) = glm.perspectiveFov(fov, size, near, far)
        fun infinitePerspectiveLh(res: Mat4d, fovY: Double, aspect: Double, near: Double) = glm.infinitePerspectiveLh(res, aspect, near)
        fun infinitePerspectiveLh(fovY: Double, aspect: Double, near: Double) = glm.infinitePerspectiveLh(aspect, near)
        fun infinitePerspectiveRh(res: Mat4d, fovY: Double, aspect: Double, near: Double) = glm.infinitePerspectiveRh(res, aspect, near)
        fun infinitePerspectiveRh(fovY: Double, aspect: Double, near: Double) = glm.infinitePerspectiveRh(aspect, near)
        fun infinitePerspective(res: Mat4d, fovY: Double, aspect: Double, near: Double) = glm.infinitePerspective(res, aspect, near)
        fun infinitePerspective(fovY: Double, aspect: Double, near: Double) = glm.infinitePerspective(aspect, near)
        fun tweakedInfinitePerspective(res: Mat4d, fovY: Double, aspect: Double, near: Double) = glm.tweakedInfinitePerspective(res, aspect, near)
        fun tweakedInfinitePerspective(res: Mat4d, fovY: Double, aspect: Double, near: Double, ep: Double) = glm.tweakedInfinitePerspective(res, aspect, near, ep)
        fun tweakedInfinitePerspective(fovY: Double, aspect: Double, near: Double) = glm.tweakedInfinitePerspective(aspect, near)
        fun tweakedInfinitePerspective(fovY: Double, aspect: Double, near: Double, ep: Double) = glm.tweakedInfinitePerspective(aspect, near, ep)

        // file: gtc/matrixTransform/gtcMatrixTranslate.kt
        fun translate(res: Mat4, m: Mat4, vX: Float, vY: Float, vZ: Float) = glm.translate(res, m)
        fun translate(res: Mat4, m: Mat4, v: Vec3) = glm.translate(res, m, v)
        fun translate(m: Mat4, vX: Float, vY: Float, vZ: Float) = glm.translate(m)
        fun translate(m: Mat4, v: Vec3) = glm.translate(m, v)
        fun translate(res: Mat4d, m: Mat4d, vX: Double, vY: Double, vZ: Double) = glm.translate(res, m)
        fun translate(res: Mat4d, m: Mat4d, v: Vec3d) = glm.translate(res, m, v)
        fun translate(m: Mat4d, vX: Double, vY: Double, vZ: Double) = glm.translate(m)
        fun translate(m: Mat4d, v: Vec3d) = glm.translate(m, v)

        // file: gtc/matrixTransform/gtcMatrixProject.kt
        fun projectZo(res: Vec3, obj: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.projectZo(res, obj, model, proj, viewport)
        fun projectZo(obj: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.projectZo(obj, model, proj, viewport)
        fun projectNo(res: Vec3, obj: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.projectNo(res, obj, model, proj, viewport)
        fun projectNo(obj: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.projectNo(obj, model, proj, viewport)
        fun project(res: Vec3, obj: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.project(res, obj, model, proj, viewport)
        fun project(obj: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.project(obj, model, proj, viewport)
        fun unProjectZo(res: Vec3, win: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.unProjectZo(res, win, model, proj, viewport)
        fun unProjectZo(win: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.unProjectZo(win, model, proj, viewport)
        fun unProjectNo(res: Vec3, win: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.unProjectNo(res, win, model, proj, viewport)
        fun unProjectNo(win: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.unProjectNo(win, model, proj, viewport)
        fun unProject(res: Vec3, win: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.unProject(res, win, model, proj, viewport)
        fun unProject(win: Vec3, model: Mat4, proj: Mat4, viewport: Vec4i) = glm.unProject(win, model, proj, viewport)
        fun projectZo(res: Vec3d, obj: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.projectZo(res, obj, model, proj, viewport)
        fun projectZo(obj: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.projectZo(obj, model, proj, viewport)
        fun projectNo(res: Vec3d, obj: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.projectNo(res, obj, model, proj, viewport)
        fun projectNo(obj: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.projectNo(obj, model, proj, viewport)
        fun project(res: Vec3d, obj: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.project(res, obj, model, proj, viewport)
        fun project(obj: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.project(obj, model, proj, viewport)
        fun unProjectZo(res: Vec3d, win: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.unProjectZo(res, win, model, proj, viewport)
        fun unProjectZo(win: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.unProjectZo(win, model, proj, viewport)
        fun unProjectNo(res: Vec3d, win: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.unProjectNo(res, win, model, proj, viewport)
        fun unProjectNo(win: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.unProjectNo(win, model, proj, viewport)
        fun unProject(res: Vec3d, win: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.unProject(res, win, model, proj, viewport)
        fun unProject(win: Vec3d, model: Mat4d, proj: Mat4d, viewport: Vec4i) = glm.unProject(win, model, proj, viewport)

        // file: typeHalf.kt
        fun toFloat32(value: Short) = glm.toFloat32(value)
        fun toFloat16(f: Float) = glm.toFloat16(f)

        // file: mat2x3/Mat2x3t.kt
        fun get(index: Int) = glm.get(index)
        fun get(column: Int, row: Int) = glm.get(column, row)

        // file: mat2x3/Mat2x3.kt
        fun to(floats: FloatArray) = glm.to(floats)
        fun to(floats: FloatArray, index: Int) = glm.to(floats, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: FloatBuffer, offset: Int) = glm.to(buf, offset)
        fun fromPointer(ptr: Ptr, transpose: Boolean = false) = glm.fromPointer(ptr, transpose)

        // file: mat2x3/Mat2x3d.kt
        fun to(doubles: DoubleArray) = glm.to(doubles)
        fun to(doubles: DoubleArray, index: Int) = glm.to(doubles, index)
        fun to(buf: ByteBuffer, offset: Int) = glm.to(buf, offset)
        fun to(buf: DoubleBuffer, offset: Int) = glm.to(buf, offset)

    }
}

